<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>倒数第k个结点</title>
    <link href="/2021/01/20/%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/2021/01/20/%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="输出该链表中倒数第k个节点"><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">输出该链表中倒数第k个节点</a></h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5.</p><p>思路：使用双指针，一个快指针，一个慢指针，先让快指针走k步，然后快慢指针一起走，直到快指针指向链表尾部时，慢指针就指向链表倒数第k个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; fast; i++, fast = fast-&gt;next);<br>        <span class="hljs-keyword">while</span> (slow &amp;&amp; fast) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="/2021/01/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <url>/2021/01/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="机器人的运动范围"><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></h1><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>输入：m = 2, n = 3, k = 1</p><p>输出：3</p><table><thead><tr class="header"><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr class="odd"><td>0</td><td>(0 0)</td><td>(0 1)</td><td>(0 2)</td></tr><tr class="even"><td>1</td><td>(1 0)</td><td>(1 1)</td><td>(1 2)</td></tr></tbody></table><p>因为机器人能够到达的格子是(0 0),(0 1), (1 0)。 思路：使用DFS或者BFS进行搜索，用一个全局变量记录符合条件的格子数。</p><p>DFS思路：使用一个vis数组，记录访问过的各自，true为访问过，false为未访问。 DFS函数参数：vis,m,n,x(当前格子横坐标),y(当前格子纵坐标) <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">vis</span><span class="hljs-params">(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n))</span></span>;<br>    dfs(vis, m, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; vis, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; direction&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    vis[x][y] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; i : direction) &#123;<br>        <span class="hljs-keyword">int</span> a = x + i.first;<br>        <span class="hljs-keyword">int</span> b = y + i.second;<br>        <span class="hljs-keyword">if</span> (a &lt; m &amp;&amp; b &lt; n &amp;&amp; !vis[a][b] &amp;&amp; count(a, b) &lt;= k)&#123;<br>            ans++;<br>            dfs(vis, m, n, a, b, k);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x) &#123;<br>        sum = sum + x % <span class="hljs-number">10</span>;<br>        x /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (y) &#123;<br>        sum = sum + y % <span class="hljs-number">10</span>;<br>        y /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure> BFS</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">vis</span><span class="hljs-params">(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n))</span></span>;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; path;<br>    path.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; direction&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (!path.empty()) &#123;<br>        <span class="hljs-keyword">auto</span> [x, y] = path.front();<br>        path.pop();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; d : direction) &#123;<br>            <span class="hljs-keyword">if</span> (x + d.first &gt;= m || y + d.second &gt;= n || vis[x + d.first][y + d.second] || count(x + d.first, y + d.second) &gt; k) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans++;<br>                vis[x+d.first][y+d.second] = <span class="hljs-literal">true</span>;<br>                path.push(<span class="hljs-built_in">make_pair</span>(x+d.first, y+d.second));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冗余连接</title>
    <link href="/2021/01/13/%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
    <url>/2021/01/13/%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="冗余连接"><a href="https://leetcode-cn.com/problems/redundant-connection/">冗余连接</a></h2><pre><code>在本问题中, 树指的是一个连通且无环的无向图。输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为:</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR<br>id1((1))<br>id2((2))<br>id3((3))<br>id1---id2<br>id1---id3<br>id2---id3<br></code></pre></td></tr></table></figure><pre><code>解释：因此该图可以删除边[2,3],使之成为一个树思路：利用并查集的思想，并查集是一个不相交的集合，一般可以用于连通片的计算等。最经常用的地方就是在克鲁斯卡尔生成树算法中。并查集可以用数组的形式进行实现，例如有一个图[[1,2], [2,3], [3,4], [1,4], [1,5]]。</code></pre><ol type="1"><li>并查集一开始初始化为如下表所示：</li></ol><table><thead><tr class="header"><th>index</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr class="odd"><td>father</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr></tbody></table><ol start="2" type="1"><li>然后逐渐添加边，</li></ol><table><thead><tr class="header"><th>index</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr class="odd"><td>father</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><ol start="3" type="1"><li>代码如下所示 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(edges.size() + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; father.size(); i++) &#123;<br>            father[i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>            <span class="hljs-keyword">if</span> (find(father, edge[<span class="hljs-number">0</span>]) != find(father, edge[<span class="hljs-number">1</span>])) &#123;<br>                Union(father, edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> edge;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; father, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        father[find(father, a)] = father[find(father, b)];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; father, <span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (a != father[a]) &#123;<br>            a = father[a];<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go</title>
    <link href="/2020/12/25/go/"/>
    <url>/2020/12/25/go/</url>
    
    <content type="html"><![CDATA[<h1 id="go语言">Go语言</h1><h2 id="包">包</h2><pre><code>1. 每个 Go 程序都是由包构成的。程序从 main 包开始运行。本程序通过导入路径 &quot;fmt&quot; 来使用它</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><pre><code>2. 此代码用圆括号组合了导入，这是“分组”形式的导入语句。也可以编写多个导入语句，例如：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math&quot;</span><br></code></pre></td></tr></table></figure><h2 id="变量">变量</h2><pre><code>1. var 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。2. 变量声明可以包含初始值，每个变量对应一个。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">var</span> c, python, java <span class="hljs-keyword">bool</span><br><span class="hljs-keyword">var</span> i, j <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span><br>fmt.Println(i, c, python, java)<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>3. 短变量声明：在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i, j <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>k := <span class="hljs-number">3</span><br>c, python, java := <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;no!&quot;</span><br>fmt.Println(i, j, k, c, python, java)<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>4. 基本类型：boolstringint  int8  int16  int32  int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名    // 表示一个 Unicode 码点float32 float64complex64 complex1285. 常量：常量的声明与变量类似，只不过是使用 const 关键字。常量可以是字符、字符串、布尔值或数值。常量不能用 := 语法声明。</code></pre><h2 id="流程控制语句">流程控制语句</h2><h3 id="for"><strong>for</strong></h3><pre><code>1. Go 只有一种循环结构：for 循环。2. 基本的 for 循环由三部分组成，它们用分号隔开：    初始化语句：在第一次迭代前执行    条件表达式：在每次迭代前求值    后置语句：在每次迭代的结尾执行</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>sum += i<br>&#125;<br>fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>3. 去掉分号的for循环就成了while循环(go语言中没有while循环)</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sum := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> sum &lt; <span class="hljs-number">1000</span> &#123;<br>sum += sum<br>&#125;<br>fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if"><strong>if</strong></h3><pre><code>同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 if 之内。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pow</span><span class="hljs-params">(x, n, lim <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span> &#123;<br><span class="hljs-keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;<br><span class="hljs-keyword">return</span> v<br>&#125;<br><span class="hljs-keyword">return</span> lim<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<br>pow(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>),<br>pow(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>),<br>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数">函数</h2><pre><code>1. 函数可以没有参数或接受多个参数。其声明格式为：func FunName(arg1 Type1, arg2 Type2, ...) Type &#123;&#125;,例如以下的add函数</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>2. 当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。即 x int, y int 可以写成x, y int 3. 函数可以返回任意数量的返回值。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Swap</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> y, x<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="指针">指针</h2><pre><code>1. go语言中的指针也是保存了变量的内存地址，零值为nil。2. 类型*T 是指向T类型的指针。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *<span class="hljs-keyword">int</span> <span class="hljs-comment">// 指向int型变量的指针</span><br></code></pre></td></tr></table></figure><pre><code>3. &amp; 取地址符号4. * 解引用符号</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">42</span><br>p = &amp;i<br>*p = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>go 没有指针运算</strong></p><h2 id="结构体-struct">结构体 struct</h2><pre><code>1. go 语言没有类2. 结构体就是由一个字段组成，例如：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    X <span class="hljs-keyword">int</span><br>    Y <span class="hljs-keyword">int</span><br>&#125; <br><br></code></pre></td></tr></table></figure><pre><code>3. 结构体字段可以用.来访问。比如有个结构体变量p，可以用p.X访问X变量。4. 结构体指针访问结构体字段，比如有个结构体指针变量p，可以用(*p).X访问X变量,也可以用p.X进行隐式间接访问。5. 结构体文法，直接列出字段的值来新分配一个结构体。使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）特殊的前缀 &amp; 返回一个指向结构体的指针。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>v1 = Vertex&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;  <span class="hljs-comment">// 创建一个 Vertex 类型的结构体</span><br>v2 = Vertex&#123;X: <span class="hljs-number">1</span>&#125;  <span class="hljs-comment">// Y:0 被隐式地赋予</span><br>v3 = Vertex&#123;&#125;      <span class="hljs-comment">// X:0 Y:0</span><br>p  = &amp;Vertex&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125; <span class="hljs-comment">// 创建一个 *Vertex 类型的结构体（指针）</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(v1, p, v2, v3)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="数组">数组</h2><pre><code>1. var name [n]T 表示拥有n个T类型的数组</code></pre><h2 id="切片">切片</h2><pre><code>1. 类型 []T 表示一个元素类型为 T 的切片。2. 可以用短变量声明一个切片，例如：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><pre><code>3. 可以用make函数创建切片，例如</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">//创建一个3个元素，容量为5的切片</span><br>s := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><pre><code>4. 切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a[low : high] <span class="hljs-comment">//左闭右开区间</span><br></code></pre></td></tr></table></figure><pre><code>5. 切片拥有 长度 和 容量。切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。6. 向切片追加元素：append 函数</code></pre><h2 id="range">Range</h2><pre><code>1. for 循环的 range 形式可遍历切片或映射。 当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> pow = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">128</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> pow &#123;<br>fmt.Printf(<span class="hljs-string">&quot;2**%d = %d\n&quot;</span>, i, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>2. 可以将下标或值赋予 _ 来忽略它。</code></pre><h2 id="map">map</h2><pre><code>1. map的声明为：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[Type1]Type2 <span class="hljs-comment">// 将类型Type1 映射到Type2中</span><br></code></pre></td></tr></table></figure><pre><code>2. make 函数会返回给定类型的映射，并将其初始化备用。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>m[<span class="hljs-string">&quot;Bell Labs&quot;</span>] = <span class="hljs-number">1</span><br>fmt.Println(m[<span class="hljs-string">&quot;Bell Labs&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法">方法</h2><pre><code>1. 方法就是一类带特殊的 接收者 参数的函数。方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。例如函数add：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-keyword">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> &#123;<br><span class="hljs-keyword">return</span> v.X + v.Y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>fmt.Println(v.Abs())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口">接口</h2><pre><code>接口类型 是由一组方法签名定义的集合。接口类型的变量可以保存任何实现了这些方法的值。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><span class="hljs-keyword">type</span> Abser <span class="hljs-keyword">interface</span> &#123;<br>Abs() <span class="hljs-keyword">float64</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a Abser<br>f := MyFloat(-math.Sqrt2)<br>v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>a = f  <span class="hljs-comment">// a MyFloat 实现了 Abser</span><br>a = &amp;v <span class="hljs-comment">// a *Vertex 实现了 Abser</span><br>fmt.Println(a.Abs())<br>&#125;<br><span class="hljs-keyword">type</span> MyFloat <span class="hljs-keyword">float64</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f MyFloat)</span> <span class="hljs-title">Abs</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> &#123;<br><span class="hljs-keyword">if</span> f &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">float64</span>(-f)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">float64</span>(f)<br>&#125;<br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-keyword">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span> <span class="hljs-title">Abs</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重建二叉树</title>
    <link href="/2020/12/21/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/12/21/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="重建二叉树"><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树</a></h2><pre><code>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。二叉树前序遍历：[根结点 左孩子 右孩子]二叉树中序遍历：[左孩子 根节点 右孩子]思路：因此首先需要从二叉树的前序遍历中找到根结点，然后通过中序遍历找到左子树和右子树。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    id1((根节点))<br>    id2((左子树))<br>    id3((右子树))<br><br>    id1--&gt;id2<br>    id1--&gt;id3<br><br></code></pre></td></tr></table></figure><pre><code>因此只要将根节点找到，然后分别计算出左子树结点个数和右子树结点个数，然后分别递归即可。例如有二叉树的前序遍历和中序遍历如下所示：前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]</code></pre><ol type="1"><li><p>因此一开始可以得到根节点为3，左子树为[9]，右子树为[15,20,7],如下图所示， <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    id1((3))<br>    id2((9))<br>    id3((15,20,7))<br>    id1--&gt;id2<br>    id1--&gt;id3<br></code></pre></td></tr></table></figure></p></li><li><p>然后再递归右子树，得到根节点为20, 左孩子和有孩子分别为15和7，如下图所示</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    id1((3))<br>    id2((9))<br>    id3((20))<br>    id4((15))<br>    id5((7))<br>    id1--&gt;id2<br>    id1--&gt;id3<br>    id3--&gt;id4<br>    id3--&gt;id5<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>在递归过程中需要记录根节点在中序遍历中的下标，得到根结点下标后，就可以得到 左右子树的结点数量大小。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.size(); i++) &#123;<br>    m[inorder[i]] = i;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>计算左右子树的结点大小 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> left = index - is;<br><span class="hljs-keyword">int</span> right = ie - index;<br></code></pre></td></tr></table></figure></li></ol><table><thead><tr class="header"><th>符号</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>ps</td><td>前序遍历左边界</td></tr><tr class="even"><td>pe</td><td>前序遍历右边界</td></tr><tr class="odd"><td>is</td><td>中序遍历左边界</td></tr><tr class="even"><td>ie</td><td>中序遍历右边界</td></tr></tbody></table><p>5.当计算完左右子树的结点大小后，需要计算左右子树边界问题</p><table><thead><tr class="header"><th>符号</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>index</td><td>根节点下标</td></tr><tr class="even"><td>ps+1</td><td>前序遍历左子树的左边界</td></tr><tr class="odd"><td>ps+left</td><td>前序遍历左子树的右边界</td></tr><tr class="even"><td>is</td><td>中序遍历左子树左边界</td></tr><tr class="odd"><td>index-1</td><td>中序遍历左子树右边界</td></tr><tr class="even"><td>pe - right + 1</td><td>前序遍历右子树的左边界</td></tr><tr class="odd"><td>pe</td><td>前序遍历右子树的右边界</td></tr><tr class="even"><td>index + 1</td><td>中序遍历右子树左边界</td></tr><tr class="odd"><td>ie</td><td>中序遍历右子树右边界</td></tr></tbody></table><ol start="6" type="1"><li>代码 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.size(); i++) &#123;<br>            m[inorder[i]] = i;<br>        &#125;<br>        TreeNode* root = build(preorder, <span class="hljs-number">0</span>, preorder.size() - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.size() - <span class="hljs-number">1</span>, m);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; pre, <span class="hljs-keyword">int</span> ps, <span class="hljs-keyword">int</span> pe, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-keyword">int</span> is, <span class="hljs-keyword">int</span> ie, <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; m)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ps &gt; pe) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125; <br>        <span class="hljs-keyword">int</span> value = pre[ps];<br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(value);<br>        <span class="hljs-keyword">if</span> (ps == pe) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> index = m[value];<br>            <span class="hljs-keyword">int</span> left = index - is;<br>            <span class="hljs-keyword">int</span> right = ie - index;<br>            root-&gt;left = build(pre, ps + <span class="hljs-number">1</span>, ps + left, inorder, is, index - <span class="hljs-number">1</span>, m);<br>            root-&gt;right = build(pre, pe - right + <span class="hljs-number">1</span>, pe, inorder, index + <span class="hljs-number">1</span>, ie, m);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组查找</title>
    <link href="/2020/12/20/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/12/20/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="二维数组中的查找"><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></h2><pre><code>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路：从左下角开始查找，当matrix[i][j] &gt; target，则向上查；当matrix[i][j] &lt; target，则向右查找。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    i := <span class="hljs-built_in">len</span>(matrix) - <span class="hljs-number">1</span>;<br>    j := <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> ; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]);  &#123;<br>        <span class="hljs-keyword">if</span> matrix[i][j] &gt; target &#123;<br>            i--;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> matrix[i][j] &lt; target &#123;<br>            j++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>找不同</title>
    <link href="/2020/12/18/%E6%89%BE%E4%B8%8D%E5%90%8C/"/>
    <url>/2020/12/18/%E6%89%BE%E4%B8%8D%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="找不同"><a href="https://leetcode-cn.com/problems/find-the-difference/">找不同</a></h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定两个字符串 s 和 <span class="hljs-built_in">t</span>，它们只包含小写字母。<br>字符串 <span class="hljs-built_in">t</span> 由字符串 s 随机重排，然后在随机位置添加一个字母。<br>请找出在 <span class="hljs-built_in">t</span> 中被添加的字母。<br></code></pre></td></tr></table></figure><ul><li>c++ <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">findTheDifference</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>&amp; c : t) &#123;<br>            sum += c;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>&amp; c : s) &#123;<br>            sum -= c;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>go <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTheDifference</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>, t <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">byte</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> res <span class="hljs-keyword">byte</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(t); i++ &#123;<br>        res += t[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        res -= s[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串压缩</title>
    <link href="/2020/12/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"/>
    <url>/2020/12/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串压缩"><a href="https://leetcode-cn.com/problems/compress-string-lcci/">字符串压缩</a></h1><pre><code>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母(a至z)。输入：&quot;aabcccccaaa&quot;输出：&quot;a2b1c5a3&quot;</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">compressString</span><span class="hljs-params">(<span class="hljs-built_in">string</span> S)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (S == <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">return</span> S;<br>        <span class="hljs-built_in">string</span> result;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">char</span> c = S[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">1</span>; i &lt; S.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (c == S[i]) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.push_back(c);<br>                result += to_string(count);<br>                count = <span class="hljs-number">1</span>;<br>                c = S[i];<br>            &#125;<br>        &#125;<br>        result.push_back(c);<br>        result += to_string(count);<br>        <span class="hljs-keyword">return</span> result.size() &lt; S.size() ? result : S;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异位词分组</title>
    <link href="/2020/12/14/%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <url>/2020/12/14/%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="字母异位词分组"><a href="https://leetcode-cn.com/problems/group-anagrams/">字母异位词分组</a></h1><pre><code>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出:[[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;bat&quot;]]</code></pre><p><strong>思路</strong>：调库就完了 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; result;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; strs.size(); i++) &#123;<br>            <span class="hljs-built_in">string</span> s = strs[i];<br>            sort(s.begin(), s.end());<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; t = m[s];<br>            t.push_back(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = m.begin(); i != m.end(); i++) &#123;<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; temp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>&amp; index : i-&gt;second) &#123;<br>                temp.push_back(strs[index]);<br>            &#125;<br>            result.push_back(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并k个有序链表</title>
    <link href="/2020/12/14/mergeKLists/"/>
    <url>/2020/12/14/mergeKLists/</url>
    
    <content type="html"><![CDATA[<h1 id="合并k个升序链表"><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表</a></h1><pre><code>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><h2 id="思路">思路</h2><pre><code>使用分治法思想，假设有l1,l2,l3,l4四个链表，首先l1和l2合并成为l12, l3和l4合并成l34，然后l12和l34合并成l。具体的代码如下所示：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">return</span> lists[l];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="hljs-number">1</span>, r));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode* tail = head;<br>        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;<br>                tail-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br>        <br>        tail-&gt;next = (l1 == <span class="hljs-literal">NULL</span> ? l2 : l1);<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unorder_map</title>
    <link href="/2020/12/14/unorder_map/"/>
    <url>/2020/12/14/unorder_map/</url>
    
    <content type="html"><![CDATA[<h1 id="unorder_map">unorder_map</h1><p>unordered_map，它是一个关联容器，内部采用的是hash表结构，拥有快速检索的功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++ 11 新标准</title>
    <link href="/2020/12/14/c++11/"/>
    <url>/2020/12/14/c++11/</url>
    
    <content type="html"><![CDATA[<h1 id="c11">C++11</h1><h2 id="新类型">1 新类型</h2><pre><code>1.1 c++11 新增了类型long long 和unsigned long long，支持64位整型。</code></pre><h2 id="初始化方式">2 初始化方式</h2><pre><code>2.1 初始化方式，使用初始化列表时，可以添加等号(=)，也可以不用： int x = &#123;5&#125;, double y&#123;5&#125;。初始化列表可用于new 表达式中， int *arr = new int[5]&#123;2 0 0 0 0&#125;。2.2 c++ 11 提供了std::initializer_list,可以用于作构造函数的参数，如：vector&lt;int&gt; a1&#123;10&#125;;vector&lt;int&gt; a2&#123;10&#125;;</code></pre><h2 id="声明">3 声明</h2><pre><code>3.1 关键字auto，用于实现自动类型推断，要求进行显示初始化，例如：auto m = 112; // type intauto pt = &amp;m; // pt is type int*3.2 关键字decltype,将变量的类型声明为表达式指定的类型。下面的语句含义是：让y的类型与x的相同，x是一个表达式。decltype(x) y例如：double x; int n;decltype(x*n) q; //将q的里欸选哪个声明为与x*n相同,double3.3 返回类型后置c++11 新增一种函数声明语法：在函数名和参数列表后面指定返回类型：double f1(double, int); // tradictional syntaxauto f2(double, int) -&gt; double;例如：template&lt;typename T, typename U&gt;auto eff(T t, U u) -&gt; decltype(T*U)&#123;&#125;解决了在编译器遇到eff的参数列表前，T和U都还不在作用域内，因此必须在参数列表后使用decltype。3.4 模板别名: using =c++ 11提供了另一种新的创建别名的语法：using itType = std::vector&lt;std::string&gt;::iterator;</code></pre><h2 id="lambda-函数">4 Lambda 函数</h2><pre><code>语法：[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125;capture list：用于捕获外部变量param list:参数列表return type: 返回类型mutable：用来说用是否可以修改捕获的变量exception：异常设定常见写法：[capture list] (params list) -&gt; return type &#123; function body &#125;[capture list] (params list)&#123; function body &#125;[capture list] &#123; function body &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>commonNode</title>
    <link href="/2020/12/12/commonNode/"/>
    <url>/2020/12/12/commonNode/</url>
    
    <content type="html"><![CDATA[<h1 id="输入两个链表找出它们的第一个公共节点"><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">输入两个链表，找出它们的第一个公共节点。</a></h1><p><img src="/img/1.png" /> <strong>思路</strong>：首先算出链表A和链表B各自的长度，然后作差求得两者长度之差，假设差为k，让长的链表先走k步，然后两个链表同时走，直到遇到公共节点。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = length(headA);<br>        <span class="hljs-keyword">int</span> n = length(headB);<br>        <span class="hljs-keyword">if</span> (m &gt;= n) &#123;<br>            <span class="hljs-keyword">int</span> k = m - n;<br>            <span class="hljs-keyword">return</span> getCommon(headA, headB, k);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> k = n - m;<br>            <span class="hljs-keyword">return</span> getCommon(headB, headA, k);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">getCommon</span><span class="hljs-params">(ListNode* headA, ListNode* headB, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        ListNode* p = headA;<br>        <span class="hljs-keyword">for</span> (; p &amp;&amp; i &lt; k; i++, p = p-&gt;next);<br>        <span class="hljs-keyword">while</span> ((p &amp;&amp; headB) &amp;&amp; (p != headB)) &#123;<br>            p = p-&gt;next;<br>            headB = headB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        ListNode* p = node;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            p = p-&gt;next;<br>            length++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>subArraySum</title>
    <link href="/2020/12/06/subArraySum/"/>
    <url>/2020/12/06/subArraySum/</url>
    
    <content type="html"><![CDATA[<h1 id="连续子数组的最大和"><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和</a></h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p><strong>设dp[i]是数组中以第i个数结尾的和，则dp[i] 与dp[i-1]有关，若dp[i-1]小于0，则dp[i]=num[i]；否则dp[i]=dp[i-1]+num[i]，因此有动态方程：</strong></p><p><span class="math display">\[dp[i] = num[i]+ max(dp[i],0)\]</span></p><p><strong>然后求dp数组中的最大值，即可得到子数组的最大和</strong></p><p><strong>然而我们需要的dp数组中的最大值，不需要其他值，因此dp数组中其他数是多余的，只需要一个变量即可，具体代码如下所示，此时时间复杂度为O(n),空间复杂度为O(1)。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0xf0000000</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0xf0000000</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            m = max(m, <span class="hljs-number">0</span>) + nums[i];<br>            ans = max(ans, m);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>printTree</title>
    <link href="/2020/12/06/printTree/"/>
    <url>/2020/12/06/printTree/</url>
    
    <content type="html"><![CDATA[<h1 id="从上到下打印二叉树"><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树</a></h1><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p><strong>BFS，层次遍历，利用index记录每一层的个数</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>        <span class="hljs-keyword">if</span> (root) &#123;<br>            q.push(root);<br>            <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v&#123;&#125;;<br>                <span class="hljs-keyword">int</span> level = q.size(); <span class="hljs-comment">//记录当前层的结点个数</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>                    TreeNode* tmp = q.front();<br>                    q.pop();<br>                    v.push_back(tmp-&gt;val);<br>                    <span class="hljs-keyword">if</span> (tmp-&gt;left) &#123;<br>                        q.push(tmp-&gt;left);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (tmp-&gt;right) &#123;<br>                        q.push(tmp-&gt;right);<br>                    &#125;<br>                &#125;<br>                ans.push_back(v);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>countOne</title>
    <link href="/2020/12/06/countOne/"/>
    <url>/2020/12/06/countOne/</url>
    
    <content type="html"><![CDATA[<h1 id="二进制中1的个数"><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a></h1><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p><strong>思路</strong>:利用‘与’运行，因为0 &amp; 1 = 0； 1 &amp; 1 = 1。例如有数1101，然后用1101 &amp; 1 = 1，然后将1101右移一位得到0110，再与1进行‘与’运行，将结果全部相加就可以得到1的个数的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            res += (n &amp; <span class="hljs-number">1</span>);<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linklist</title>
    <link href="/2020/12/04/linklist/"/>
    <url>/2020/12/04/linklist/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-关于链表的题">Leetcode 关于链表的题</h1><ol type="1"><li>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></li></ol><p>思路:设置双指针，slow和fast, 首先让fast指针先走k步，然后slow指针和fast一起走，直到fast指针指向最后一个元素，此时slow指向倒数第k个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; fast; i++, fast = fast-&gt;next);<br>        <span class="hljs-keyword">while</span> (slow &amp;&amp; fast) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">删除链表的节点</a></li></ol><p>输入: head = [4,5,1,9], val = 5</p><p>输出: [4,1,9]</p><p>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        pre-&gt;next = head;<br>        ListNode* p = pre-&gt;next;<br>        ListNode* p2 = pre;<br>        <span class="hljs-keyword">for</span> (; p &amp;&amp; p-&gt;val != val; p = p-&gt;next, p2 = p2-&gt;next);<br>        p2-&gt;next = p-&gt;next;<br>        <span class="hljs-keyword">return</span> pre-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reverseLinkList</title>
    <link href="/2020/12/02/reverseLinkList/"/>
    <url>/2020/12/02/reverseLinkList/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</a></p><pre><code>输入：head = [1,3,2]输出：[2,3,1]</code></pre><p><strong>思路</strong>：首先将链表进行原地逆转。 例如有链表：dummy-&gt;1-&gt;3-&gt;2; 首先设置两个临时变量pre, p分别指向值为1的节点和值为3的节点。然后进行循环，修改指针：</p><pre><code>第一次循环：pre-&gt;next = p-&gt;next,即1-&gt;2,p-&gt;next = dummy-&gt;next;即3-&gt;1;dummy-&gt;next = p;即dummy-&gt;3-&gt;1-&gt;2;然后修改p指向值为2的节点第二次循环后就可以得到:dummy-&gt;2-&gt;3-&gt;1;</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            result.push_back(head-&gt;val);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        ListNode* dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        ListNode* pre = dummy-&gt;next;<br>        ListNode* p = pre-&gt;next;<br>        <span class="hljs-keyword">while</span> (pre-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>            pre-&gt;next = p-&gt;next;<br>            p-&gt;next = dummy-&gt;next;<br>            dummy-&gt;next = p;<br>            p = pre-&gt;next;<br>        &#125;<br>        p = dummy;<br>        p = p-&gt;next;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>            result.push_back(p-&gt;val);<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos</title>
    <link href="/2020/12/01/centos/"/>
    <url>/2020/12/01/centos/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一下linux常用操作">记录一下linux常用操作</h1><h2 id="centos-8-上的换源">centos 8 上的换源</h2><pre><code> 1 使用命令cd /etc/yum.repos.d, 进入源文件所在目录. 2 然后将之前的源文件备份一下，cp CentOS-Base.repo CentOS-Base.repo.back 3 再使用wget下载源文件，wget -O CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo 4 yum makecache 5 yum update</code></pre><h2 id="记录常见错误以及解决方法">记录常见错误，以及解决方法</h2><h3 id="常见错误1xxx不在sudoers文件中">常见错误1，xxx不在sudoers文件中</h3><pre><code>例如在shell终端输入sudo yum install vim， 此时报错字样为：henry is not in the sudoers file.  This incident will be reported.解决办法：1.首先进入root用户下，在shell终端输入su，然后输入用户密码。2.添加sudo文件的写权限,命令是:chmod u+w /etc/sudoers3.编辑sudoers文件，命令vim /etc/sudoers4.找到这行 root ALL=(ALL) ALL,在他下面添加xxx ALL=(ALL) ALL (这里的xxx是你的用户名)完成！</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>binarySearch</title>
    <link href="/2020/12/01/binarySearch/"/>
    <url>/2020/12/01/binarySearch/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找">二分查找</h2><pre><code>1. 在有序数组nums中查找值为target的下标，查找失败返回-1</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><pre><code>2. 在有序数组nums中查找都一个比target大的数,失败返回</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> ans = nums.size();<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>            <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>3. 在有序数组nums中查找都target第一次出现和最后一次出现的位置,失败返回[-1,-1].输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]</code></pre><p><strong>思路</strong>: 首先先用二分查找找到第一个target出现的位置left，然后查找第一个大于target的位置right，然后用right-1就是target出现最后一次的位置，代码如下 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = binarySearch(nums, target, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">int</span> right = binarySearch(nums, target, <span class="hljs-literal">false</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (left &lt;= right &amp;&amp; right &lt; nums.size()  &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &#123;left, right&#125;; <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">bool</span> flag)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.size() - <span class="hljs-number">1</span> ;<br>        <span class="hljs-keyword">int</span> ans = nums.size();<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target || (flag &amp;&amp; nums[mid] &gt;= target)) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                ans = mid;<br>            &#125; <span class="hljs-keyword">else</span>  &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fourSumCount</title>
    <link href="/2020/11/29/fourSumCount/"/>
    <url>/2020/11/29/fourSumCount/</url>
    
    <content type="html"><![CDATA[<h2 id="四数之和"><a href="https://leetcode-cn.com/problems/4sum-ii/">四数之和</a></h2><pre><code>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</code></pre><p><strong>思路</strong> 使用散列表，先将数组A和B中任意两个数之和放入哈希映射中，每一个键是A[i]+B[j],值是对应的次数。然后在数组C和D之间相对应的建，当遇到-(C[k]+D[l])，则答案加1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; B, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; C, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; D)</span> </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; count;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;u : A) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;v : B) &#123;<br>                ++count[u+v];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;u : C) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;v : D) &#123;<br>                <span class="hljs-keyword">if</span> (count.count(-u-v))<br>                    ret += count[-(u+v)];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>convex-optimization</title>
    <link href="/2020/11/27/convex-opt/"/>
    <url>/2020/11/27/convex-opt/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-2">Chapter 2</h1><h2 id="convex-set">convex set</h2><h3 id="affine-and-convex-set">2.1 Affine and convex set</h3><h4 id="lines-and-line-segment">2.1.1 Lines and line segment</h4><h4 id="affine-sets">2.1.2 Affine sets</h4><p>​ A set <span class="math inline">\(C \in R^n\)</span> is <strong>affine</strong> if the line through any two distinct points in C lies in C. We refer to a point of the form $ _1x_1++_k x_k$, where $_1++_k=1 $, as an affine combination of points <span class="math inline">\(x_1,\dots,x_k\)</span>. If C is an affine set, <span class="math inline">\(x_1,\dots,x_k \in C\)</span> and<span class="math inline">\(\theta_1+\dots+\theta_k=1\)</span>,then the point <span class="math inline">\(\theta_1x_1+\dots+\theta_k x_k\)</span> also belongs to C.</p><p>​ The set of all affine combinations of points in some <span class="math inline">\(C\subseteq R^n\)</span> is called the <strong>affine hull（仿射包）</strong>of C, and denoted <strong>aff</strong> C: <span class="math display">\[aff\quad C = \{\theta_1x_1+\dots+\theta_k x_k | x_1, \dots,x_k \in C, \theta_1+\dots+\theta_k=1\}\]</span> The affine hull is the smallest affine set that contains C.</p><h4 id="affine-dimension-and-relative-interior">2.1.3 Affine dimension and relative interior</h4><p>​ The <strong>affine dimension</strong> of a set C as the dimension of its affine hull.</p><p>​ The <strong>relative interior</strong> of a set C is denoted <strong>relint C</strong>,as its interior relative to <strong>aff C</strong>: <span class="math display">\[relint \quad C=\{x\in C|B(x,r) \cap aff \quad C \subseteq C \quad for \quad some \quad r&gt;0\}\]</span> where <span class="math inline">\(B(r,x)=\{ y| ||y-x|| \le r\}\)</span>.</p><p>​ The <strong>relative boundary</strong> of a set C as cl C  relint C, where cl C is the closure of C.</p><h4 id="convex-set-1">2.1.4 Convex set</h4><p>​ A set C is convex if the line segment between any two point in C lies in C. i.e., if any <span class="math inline">\(x_1,x_2 \in C\)</span> and any <span class="math inline">\(\theta \in [0,1]\)</span>, we have <span class="math inline">\(\theta x_1+(1-\theta)x_2 \in C\)</span>.</p><p>​ We call a point of the from <span class="math inline">\(\theta_1x_1+\dots+\theta_k x_k\)</span>, where <span class="math inline">\(\theta_1+\dots+\theta_k=1\)</span> and <span class="math inline">\(\theta_i \ge 0, i=1,\dots,k\)</span>, a convex combination of the points <span class="math inline">\(x_1,\dots,x_k\)</span>.</p><p>​ The convex hull of a set C,denoted <strong>conv C</strong>, is the set of all convex combinations of points in C：</p><p><span class="math display">\[convC=\{\theta_1x_1+\dots+\theta_k x_k | x_1, \dots,x_k \in C, \theta_1+\dots+\theta_k=1, \theta_i \ge 0, i=1,\dots,k\}\]</span></p><h4 id="cones">2.1.5 Cones</h4><p>​ A set C is called a cone, if for every <span class="math inline">\(x \in C\)</span> and <span class="math inline">\(\theta \ge 0\)</span>,we have <span class="math inline">\(\theta x \in C\)</span>. A set C is convex cone if it is convex and a cone.</p><h3 id="section">2.2</h3><h4 id="hyperplanes-and-halfspaces">2.2.1 Hyperplanes and halfspaces</h4><p>​ A hyperplane is a set of the form <span class="math inline">\(\{x|a^Tx=b\}\)</span>, where <span class="math inline">\(a\in R^n,a\ne 0\)</span> and <span class="math inline">\(b\in R\)</span>. It also has the form <span class="math inline">\(\{x|a^T(x-x_0)=0\}\)</span>, where <span class="math inline">\(x_0\)</span>is any point in the hyperplane(any point satisfies <span class="math inline">\(a^Tb=0\)</span>).</p><h4 id="euclidean-balls-and-ellipsoids">2.2.2 Euclidean balls and ellipsoids</h4><p>​ A ball in <span class="math inline">\(R^n\)</span> has the form <span class="math inline">\(B(x_c,r)=\{x| \quad\left\|x-x_c\right\|_2\le r \}=\{x| (x-x_c)^T(x-x_c) \le r^2\}\)</span></p><h4 id="norm-balls-and-norm-cones">2.2.3 Norm balls and norm cones</h4><p>​ A norm ball associated with the norm <span class="math inline">\(\left \|·\right \|\)</span> is the set <span class="math inline">\(\{x | \left\|x-x_c\right\| \le r\}\)</span>.</p><p>​ A norm cones associated with the norm <span class="math inline">\(\left \|·\right \|\)</span> is the set <span class="math inline">\(\{(x,t) | \left\|x\right\| \le t\}\)</span>.</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长字串</title>
    <link href="/2020/11/26/first/"/>
    <url>/2020/11/26/first/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串">字符串</h3><ul><li><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</a></p><p><strong>输入实例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度 3</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>思路</strong></p><p>​ 采用滑动窗口的思想，设置两个指针，一个指针<strong>i</strong>指向左边，一个指针<strong>rk</strong> 指向右边，此时最长的字符字串为<strong>s[i]s[i+1]...s[rk]</strong></p><p>，此时长度为<strong>rk-i+1</strong>。具体思路如下所示:</p><ol type="1"><li><p>abcabcbb,首先i指针指向第一个字符，可以得到最长的无重复字符字串为(abc)abcbb, ()表示最长的无重复字符字串。</p></li><li><p>abcabcbb a(bca)bcbb</p></li><li><p>abcabcbb,ab(cab)cbb</p></li><li><p>abcabcbb,abc(abc)bb</p></li><li><p>abcabcbb,abca(bc)bb</p></li><li><p>abcabcbb,abcab(cb)b</p></li><li><p>abcabcbb,abcabcb(b)</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">char</span>&gt; check;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">int</span> rk = <span class="hljs-number">-1</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                check.erase(s[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (rk + <span class="hljs-number">1</span> &lt; s.size() &amp;&amp; check.count(s[rk + <span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>)&#123;<br>                check.insert(s[rk + <span class="hljs-number">1</span>]);<br>                ++rk;<br>            &#125;<br>            res = max(res, rk - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
