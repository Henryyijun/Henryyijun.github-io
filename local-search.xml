<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>include双引号和尖括号的区别</title>
    <link href="/2021/03/15/include%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/03/15/include%E5%8F%8C%E5%BC%95%E5%8F%B7%E5%92%8C%E5%B0%96%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何让.h文件不被重复引用</title>
    <link href="/2021/03/15/%E5%A6%82%E4%BD%95%E8%AE%A9-h%E6%96%87%E4%BB%B6%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E5%BC%95%E7%94%A8/"/>
    <url>/2021/03/15/%E5%A6%82%E4%BD%95%E8%AE%A9-h%E6%96%87%E4%BB%B6%E4%B8%8D%E8%A2%AB%E9%87%8D%E5%A4%8D%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="如何让.h文件不被重复引用">如何让.h文件不被重复引用</h1><p>为了避免让.h文件不被重复引用，有三种方式可以实现该操作，主要为：</p><ol type="1"><li>使用宏定义</li><li>使用<code>#pragma once</code>语句</li><li>使用<code>_Pragma</code>操作符</li></ol><p>例如有如下所示的 <code>C++</code> 项目，其内部含有 <code>A.h</code> 和 <code>B.h</code> 这 2 个头文件以及 <code>main.cpp</code> 源文件，其各自包含的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// A.h</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>    <br>&#125;;<br><br><br><span class="hljs-comment">// B.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;A.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span><br>    <br>&#125;;<br><br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;A.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;B.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行此项目后可以发现，编译器报 (VS studio 2019)<code>“A&quot; : &quot;class” 类型重定义</code> 错误。这是因为在 <code>B.h</code> 文件中已经 <code>include</code> 了一次 <code>A.h</code>，而在 <code>main.cpp</code>主程序又同时 <code>#include</code> 了 <code>A.h</code> 和 <code>B.h</code>，即 <code>A</code> 类的定义被引入了 2 次，<code>C++</code>不允许同一个类被重复定义。</p><p>因此我们此时可以使用之前提到的三种方法处理这种情况，避免头文件的重复引入。</p><ul><li><p>使用宏定义避免</p><p>在实际的<code>C++</code>开发中，可以使用如下的宏定义形式进行避免头文件重复引入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _NAME_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _NAME_H</span><br><span class="hljs-comment">// 头文件内容</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>其中，_NAME_H 是宏的名称。需要注意的是，这里设置的宏名必须是独一无二的，不要和项目中其他宏的名称相同。当程序中第一次 <code>#include</code> 该文件时，由于 <code>_NAME_H</code> 尚未定义，所以会定义 <code>_NAME_H</code> 并执行 “头文件内容” 部分的代码；当发生多次 <code>#include</code> 时，因为前面已经定义了 <code>_NAME_H</code>，所以不会再重复执行 “头文件内容” 部分的代码。</p><p>因此，我们对之前的两个类文件进行修改，添加宏定义语句，代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// A.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _A_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _A_H</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><br><span class="hljs-comment">// B.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _B_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _B_H</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;A.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &#123;</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><br><span class="hljs-comment">//main.cpp</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;A.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;B.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然该项目 <code>main.cpp</code> 文件中仍 <code>#include</code> 了 2 次 <code>A.h</code>，但鉴于 <code>_A_H</code> 宏只能定义一次，所以 <code>A</code> 类也仅会定义一次。再次执行该项目会发现，其可以正常执行。</p></li><li><p>使用<code>#pragma once</code>语句</p><p>除了前面第一种最常用的方式之外，还可以使用 <code>#pragma one</code> 指令，将其附加到指定文件的最开头位置，则该文件就只会被 <code>#include</code> 一次。和 <code>ifndef</code> 相比，<code>#pragma once</code> 不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以效率很高。但值得一提的是，并不是每个版本的编译器都能识别 <code>#pragma once</code> 指令，一些较老版本的编译器就不支持该指令（执行时会发出警告，但编译会继续进行），即 <code>#pragma once</code> 指令的兼容性不是很好。</p></li><li><p>使用<code>_Pragma</code>操作符</p><p><code>C99</code> 标准中新增加了一个和 <code>#pragma</code> 指令类似的 <code>_Pragma</code> 操作符，其可以看做是 <code>#pragma</code> 的增强版，不仅可以实现 <code>#pragma</code> 所有的功能，更重要的是，<code>_Pragma</code> 还能和宏搭配使用。</p><p>当处理头文件重复引入问题时，可以将如下语句添加到相应文件的开头：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">_Pragma(<span class="hljs-string">&quot;once&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重复项删除</title>
    <link href="/2021/03/09/%E9%87%8D%E5%A4%8D%E9%A1%B9%E5%88%A0%E9%99%A4/"/>
    <url>/2021/03/09/%E9%87%8D%E5%A4%8D%E9%A1%B9%E5%88%A0%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="删除字符串中的所有相邻重复项"><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">删除字符串中的所有相邻重复项</a></h1><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。</p><p>思路：使用栈保存非重复项，便利字符串，当遇到的字符和栈顶元素相同时，则让栈顶元素退栈，否则入栈，最终将得到的栈转化为字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">string</span> S)</span> </span>&#123;<br>        <span class="hljs-built_in">string</span> res;<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">char</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>&amp; ch : S) &#123;<br>            <span class="hljs-keyword">if</span> (s.empty()) &#123;<br>                s.push(ch);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (ch == s.top()) &#123;<br>                    s.pop();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    s.push(ch);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!s.empty()) &#123;<br>            res.push_back(s.top());<br>            s.pop();<br>        &#125;<br>        reverse(res.begin(), res.end());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>c++string本身提供了类似栈的操作，因为我们不需要开多一个额外的栈进行辅助。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-built_in">string</span> S)</span> </span>&#123;<br>        <span class="hljs-built_in">string</span> res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>&amp; ch : S) &#123;<br>            <span class="hljs-keyword">if</span> (!res.empty() &amp;&amp; ch == res.back()) &#123;<br>                res.pop_back();<br>            &#125; <span class="hljs-keyword">else</span>&#123;<br>                res.push_back(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>俄罗斯套娃</title>
    <link href="/2021/03/08/%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83/"/>
    <url>/2021/03/08/%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83/</url>
    
    <content type="html"><![CDATA[<h1 id="俄罗斯套娃"><a href="#俄罗斯套娃" class="headerlink" title="俄罗斯套娃"></a><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">俄罗斯套娃</a></h1><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。<br>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。<br>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>思路：首先对信封的宽度进行排序，然后求高度的最长递增子序列。求解子序列问题是一个动态规划问题，假设有序列为：<br>num=[2 1 3 5 4 7]。使用dp数组进行记录，dp[i]的值表示以num[i]作为结尾的递增子序列的长度。一开始，dp全部初始化为1， 然后更新dp的动态方程为:<br>$$<br>dp[i] = max_{0&lt;j&lt;i}(dp[i], dp[j] + 1);<br>$$</p><p>1 dp数组初始化<br>|num|2|1|3|5|4|7|<br>|–|–|–|–|–|–|–|<br>|dp|1|1|1|1|1|1|</p><p>2 更新dp[1]<br>因为num[1] &gt; num[0]不成立，所以dp[1] = 1。<br>|num|2|1|3|5|4|7|<br>|–|–|–|–|–|–|–|<br>|dp|1|1|1|1|1|1|</p><p>3 更新dp[2]<br>因为num[2] &gt; num[0]成立，所以dp[2] = dp[0]+1;<br>因为num[2] &gt; num[1]成立，所以dp[2] = dp[1]+1;<br>最后dp[2] = ，max(dp[1]+1,dp[0]+1);所以dp[2]=2。<br>|num|2|1|3|5|4|7|<br>|–|–|–|–|–|–|–|<br>|dp|1|1|2|1|1|1|</p><p>3 依次类推更新其他值<br>|num|2|1|3|5|4|7|<br>|–|–|–|–|–|–|–|<br>|dp|1|1|2|3|3|4|</p><ol start="4"><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;<br>        sort(envelopes.begin(), envelopes.end(), [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; b) -&gt; <span class="hljs-keyword">bool</span> &#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>        &#125;); <span class="hljs-comment">//首先进行排序</span><br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(envelopes.size(), <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; envelopes.size(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (envelopes[i][<span class="hljs-number">1</span>] &gt; envelopes[j][<span class="hljs-number">1</span>] &amp;&amp; envelopes[i][<span class="hljs-number">0</span>] &gt; envelopes[j][<span class="hljs-number">0</span>]) &#123;<br>                    dp[i] = max(dp[i], dp[j] + <span class="hljs-number">1</span>); <span class="hljs-comment">//对高度求最长递增子序列</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *max_element(dp.begin(), dp.end());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>espirit</title>
    <link href="/2021/03/04/espirit/"/>
    <url>/2021/03/04/espirit/</url>
    
    <content type="html"><![CDATA[<h1 id="espirit---an-eigenvalue-approach-to-autocalibrating-parallel-mri">ESPIRiT - An Eigenvalue Approach to Autocalibrating Parallel MRI</h1><h2 id="theory">1 THEORY</h2><h3 id="sense">1.1SENSE</h3><p>   在MRI重建中，SENSE类方法将MRI重建视作为一个线性逆问题。假设m表示一张图像，令<span class="math inline">\(S_i\)</span> 表示第i个线圈的敏感度矩阵(对角矩阵),<span class="math inline">\(F\)</span>表示离散傅里叶变换，<span class="math inline">\(P\)</span>表示采样矩阵。则第i个线圈得到的数据可以表示为: <span class="math display">\[y_i = PFS_i m  \quad (1)\]</span> 当<span class="math inline">\(S_i\)</span>已知时，该问题可以直接通过最小二乘法求解。</p><h3 id="grapppa">1.2 GRAPPPA</h3><p>   GRAPPA是一种逐线圈自动校准的重建算法，该算法将重建过程视作为一个k空间的插值过程，将未获得k空间数据通过已获得的数据进行线性组合得到。</p><p>  为了描述GRAPPA算法，定义一些符号</p><ul><li><span class="math inline">\(R_r\)</span> :该算子表示从位置r周围的所有网格中选择一个k空间块。</li><li><span class="math inline">\(P_r\)</span> :仅从k空间块中选择采集样本的局部采样模式。</li><li><span class="math inline">\(y\)</span> :向量形式的多线圈k空间网格，未获取的数据被零填充。</li><li><span class="math inline">\(x_i\)</span> :第i个线圈中重建后得到的数据</li><li><span class="math inline">\(x_i(r)\)</span> :第i个线圈中，位置r的重建数据</li><li><span class="math inline">\(g_{ri}\)</span> :GRAPPA kernel</li></ul><p>  在GRAPPA重建算法中，在位置r中未采样的数据由以下式子得到： <span class="math display">\[x_i(r)=(P_rR_ry)^Tg_{ri} \quad (2)\]</span> 因此当GRAPPA kernel未知，<span class="math inline">\(x_i\)</span>已知时，我们可以通过求解(2)得到<span class="math inline">\(g_{ri}\)</span>。一般情况下，在得到的k空间数据中有一块全采样的数据，位于数据中心，这块数据被称为校准数据(calibration data),通过该数据得到矩阵被称为标准矩阵(calibration matrix)，记为A。如Figure 1，左上角为得到的k空间数据，该数据中央黑色部分为全采样，即为标准矩阵(上中图)。上右图是校准数据得到的校准矩阵，该矩阵通过设置一个窗口(3*3),然后将窗口中的数据拉成一行向量，即可以得到校准矩阵的一行向量，再通过滑动该窗口，不断得到校准矩阵的数据。</p><p>   为了得到GRAPPA kernel，使用校准矩阵改写式子(2),</p><p><span class="math display">\[\begin{aligned}x_i(r)&amp;=(P_rR_ry)^Tg_{ri} \\          &amp;=y^TR_r^TP_r^Tg_{ri}\\          &amp;=(R_ry)^TP_r^Tg_{ri} \\          &amp;=AP_r^Tg_{ri}\end{aligned}\]</span> 若用<span class="math inline">\(y_i^{AC}\)</span>表示第i个线圈得到的校准数据，则可以得到式子(3) <span class="math display">\[y_i^{AC} = AP_r^Tg_{ri} \quad (3)\]</span> 通过求解式子(3), 可以得到未知的<span class="math inline">\(g_{ri}\)</span>，一般通过Tikhonov正则化最小二乘法进行求解。 <span class="math display">\[argmin_{g_{ri}} \Vert AP_r^T-y_i^{AC} \Vert^2\]</span></p><p>通过构造，矩阵A的一个列是<span class="math inline">\(y_i^{AC}\)</span>，如Figure 1 中上中图和上右图所以，橙色部分的一块一矩阵即为矩阵A的第五列。因为可以将<span class="math inline">\(y_i^{AC}\)</span>写成 <span class="math inline">\(Ae_i\)</span>,<span class="math inline">\(e_i\)</span>表示某个位置为1，其他为0为的向量，用于选择矩阵的第i列。因此通过该性质，重写式子(3),可以写成：</p><p><span class="math display">\[\begin{aligned}0&amp;=AP_r^Tg_{ri}-y_i^{AC}\\&amp;=AP_r^Tg_{ri}-Ae_i \\&amp;=A(P_r^Tg_{ri} - e_i) \quad (4)\end{aligned}   \]</span> 从式子(4)中可以发现，<span class="math inline">\(P_r^Tg_{ri} - e_i\)</span>是矩阵A的零空间向量。零空间的存在意味着A中存在冗余，从而意味着k空间块之间的相关性，这可以用来合成丢失的样本。由于零空间的特殊性，因此我们可以直接分析零空间。</p><figure><img src="https://i.loli.net/2021/03/08/OaNkGrSzJKZADVb.png" alt="Figure 1" /><figcaption>Figure 1</figcaption></figure><h3 id="svd和零空间重建">1.3 SVD和零空间重建</h3><p>   使用奇异值分解的方法分析校准矩阵A，奇异值分解的形式为： <span class="math display">\[A=U\Sigma V^H \quad (5)\]</span> 矩阵V的列是矩阵行空间的基，因此可以将矩阵V分成<span class="math inline">\(V_{\bot}\)</span>和<span class="math inline">\(V_{\Vert}\)</span>,分别span A的零空间和行空间。从Figure 2 中可以看出，对校准矩阵矩阵进行奇异值分解后，我们可以利用<span class="math inline">\(V_{\Vert}\)</span>的数据推出未采样的数据。</p><p>   给定欠采样的k空间网格，重构x的每个k空间块必须满足两个约束: <span class="math display">\[\begin{aligned}V_{\Vert}V_{\Vert}^HR_rx &amp;= R_rx  \quad or \quad V_{\bot}^HR_rx = 0 \quad &amp;(6a)\\P_rR_rx&amp;=P_rR_rx \quad &amp;(6b)\end{aligned}\]</span> (6a)是与校准的一致性，(6b)是与数据采集的一致性。在最小二乘意义上解释(形式上超定的)零空间约束集产生了正规方程</p><p><span class="math display">\[\sum_{r}R_r^HV_{\bot}V_{\bot}^HR_rx = 0 \quad (7)\]</span></p><p>式子(7)进一步可以写成</p><p><span class="math display">\[\sum_{r}R_r^H (I- V_{\Vert}V_{\Vert}^H) R_rx = 0 \quad (8)\]</span></p><p><span class="math display">\[M^{-1}\sum_{r}R_r^H V_{\Vert}V_{\Vert}^H R_rx = 0 \quad (9)\]</span> 其中式子(9)中的M表示<span class="math inline">\(\sum_{r}R_r^HR_r\)</span>。以矩阵形式重写第一个约束，并合并第二个约束的所有相同的方程，得到 <span class="math display">\[\begin{aligned}\mathcal{W}x &amp;=x  \quad (10a)\\\mathcal{P}x &amp;= \mathcal{P}y \quad (10b)\end{aligned} \]</span></p><figure><img src="https://i.loli.net/2021/03/08/aPNvjHZbIAgxSym.png" alt="Figure 2" /><figcaption>Figure 2</figcaption></figure><h3 id="sensitivity-map-as-an-eigenvalue-problem">1.4 Sensitivity map as an eigenvalue problem</h3><p>    假设x是W-I的零空间的解，则满足<span class="math inline">\(Wx=x\)</span>。如果我们用线圈灵敏度加权的原始图像的k空间表示x，得到 <span class="math display">\[x=FSm \quad (11)\]</span> 其中，<span class="math inline">\(S=[S_1,S_2,...,S_N]^T\)</span> 是堆叠线圈灵敏度的向量，则等式(10a)可以写为： <span class="math display">\[WFSm = FSm \quad (12)\]</span> 两边都进行傅里叶逆变换可以得到， <span class="math display">\[F^{-1}WFSm=Sm \quad (13)\]</span> 通过式子(13)可以看出，1是矩阵<span class="math inline">\(F^{-1}WF\)</span>的特征值，特征向量是<span class="math inline">\(Sm\)</span>.因为算子W是半正定矩阵值卷积，所以它在图像域中解耦成点态半正定矩阵运算: <span class="math display">\[F^{-1}\mathcal{W}F|_q=\mathcal{G_q} \quad (14)\]</span> 算子W的特征值分解被简化为求解图像空间中<span class="math inline">\(G_q\)</span>每个位置q的特征值分解。计算<span class="math inline">\(G_q\)</span>的过程如Figure 4所示。定义在位置q上的敏感度<span class="math inline">\(\vec{s}(q)=[s_1(q),...,s_N(q)]^T\)</span>,则等式(13)可以推出： <span class="math display">\[\mathcal{G_q}\vec{s}(q)m(q)=\vec{s_r}m(q) \quad (15)\]</span> 假设<span class="math inline">\(m(q)\)</span>不等于0，则可以得到： <span class="math display">\[\mathcal{G_q}\vec{s}(q)=\vec{s_q} \quad (15)\]</span> 因此，显式灵敏度图可以通过所有Gq的特征值分解找到，只选择对应于特征值&quot; =1 &quot;的特征向量 <img src="https://i.loli.net/2021/03/08/uXNIlDFy2h6kYe3.png" alt="Figure 4" /></p><h3 id="espirit-implementation-using-soft-sense">1.5 ESPIRiT : Implementation Using Soft SENSE</h3><p>  在计算一组灵敏度后，可以执行标准的SENSE重建。在某些情况下，采集中的误差会导致出现特征值为“=1”的多个特征向量或小于1的附加特征值，这表明信号分量不能用严格的SENSE模式来解释。这推动了重建过程的扩展:不是使用一组单一的灵敏度图，而是使用等式(1)扩展到“软”SENSE重建，其使用基于多个图像分量<span class="math inline">\(m^j\)</span>和多组映射<span class="math inline">\(S^j\)</span>的信号的松弛模型:</p><p><span class="math display">\[y_i=\mathcal{P} \mathcal{F}\sum_{j=1}^{M}S_i^jm^j \quad (16)\]</span> 如上所述，重建图像的求解为一个优化问题，并且使用正则化方法，具体的形式如下所示：</p><p><span class="math display">\[J(m^1,...,m^M)=\sum_{i=1}^{N}\Vert y_i-\mathcal{P} \mathcal{F}\sum_{j=1}^{M}S_i^jm^j \Vert^2_2 + \alpha\sum_{j=1}^{M}\mathcal{Qm^j}  \quad (17)\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>MRI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>倒数第k个结点</title>
    <link href="/2021/01/20/%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/2021/01/20/%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="输出该链表中倒数第k个节点"><a href="#输出该链表中倒数第k个节点" class="headerlink" title="输出该链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">输出该链表中倒数第k个节点</a></h1><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.</p><p>思路：使用双指针，一个快指针，一个慢指针，先让快指针走k步，然后快慢指针一起走，直到快指针指向链表尾部时，慢指针就指向链表倒数第k个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; fast; i++, fast = fast-&gt;next);<br>        <span class="hljs-keyword">while</span> (slow &amp;&amp; fast) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人的运动范围</title>
    <link href="/2021/01/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <url>/2021/01/19/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">机器人的运动范围</a></h1><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>输入：m = 2, n = 3, k = 1</p><p>输出：3</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>0</td><td>(0 0)</td><td>(0 1)</td><td>(0 2)</td></tr><tr><td>1</td><td>(1 0)</td><td>(1 1)</td><td>(1 2)</td></tr></tbody></table><p>因为机器人能够到达的格子是(0 0),(0 1), (1 0)。<br>思路：使用DFS或者BFS进行搜索，用一个全局变量记录符合条件的格子数。</p><p>DFS思路：使用一个vis数组，记录访问过的各自，true为访问过，false为未访问。<br>DFS函数参数：vis,m,n,x(当前格子横坐标),y(当前格子纵坐标)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">vis</span><span class="hljs-params">(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n))</span></span>;<br>    dfs(vis, m, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;&amp; vis, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; direction&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    vis[x][y] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; i : direction) &#123;<br>        <span class="hljs-keyword">int</span> a = x + i.first;<br>        <span class="hljs-keyword">int</span> b = y + i.second;<br>        <span class="hljs-keyword">if</span> (a &lt; m &amp;&amp; b &lt; n &amp;&amp; !vis[a][b] &amp;&amp; count(a, b) &lt;= k)&#123;<br>            ans++;<br>            dfs(vis, m, n, a, b, k);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x) &#123;<br>        sum = sum + x % <span class="hljs-number">10</span>;<br>        x /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (y) &#123;<br>        sum = sum + y % <span class="hljs-number">10</span>;<br>        y /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>BFS</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">vis</span><span class="hljs-params">(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(n))</span></span>;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; path;<br>    path.push(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; direction&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (!path.empty()) &#123;<br>        <span class="hljs-keyword">auto</span> [x, y] = path.front();<br>        path.pop();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; d : direction) &#123;<br>            <span class="hljs-keyword">if</span> (x + d.first &gt;= m || y + d.second &gt;= n || vis[x + d.first][y + d.second] || count(x + d.first, y + d.second) &gt; k) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans++;<br>                vis[x+d.first][y+d.second] = <span class="hljs-literal">true</span>;<br>                path.push(<span class="hljs-built_in">make_pair</span>(x+d.first, y+d.second));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冗余连接</title>
    <link href="/2021/01/13/%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
    <url>/2021/01/13/%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="冗余连接"><a href="#冗余连接" class="headerlink" title="冗余连接"></a><a href="https://leetcode-cn.com/problems/redundant-connection/">冗余连接</a></h2><pre><code>在本问题中, 树指的是一个连通且无环的无向图。输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。输入: [[1,2], [1,3], [2,3]]输出: [2,3]解释: 给定的无向图为:</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR<br>id1((1))<br>id2((2))<br>id3((3))<br>id1---id2<br>id1---id3<br>id2---id3<br></code></pre></td></tr></table></figure><pre><code>解释：因此该图可以删除边[2,3],使之成为一个树思路：利用并查集的思想，并查集是一个不相交的集合，一般可以用于连通片的计算等。最经常用的地方就是在克鲁斯卡尔生成树算法中。并查集可以用数组的形式进行实现，例如有一个图[[1,2], [2,3], [3,4], [1,4], [1,5]]。</code></pre><ol><li>并查集一开始初始化为如下表所示：</li></ol><table><thead><tr><th>index</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>father</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr></tbody></table><ol start="2"><li>然后逐渐添加边，</li></ol><table><thead><tr><th>index</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>father</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>3. 代码如下所示</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">father</span><span class="hljs-params">(edges.size() + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; father.size(); i++) &#123;<br>            father[i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; edge : edges) &#123;<br>            <span class="hljs-keyword">if</span> (find(father, edge[<span class="hljs-number">0</span>]) != find(father, edge[<span class="hljs-number">1</span>])) &#123;<br>                Union(father, edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> edge;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; father, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        father[find(father, a)] = father[find(father, b)];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; father, <span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (a != father[a]) &#123;<br>            a = father[a];<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go</title>
    <link href="/2020/12/25/go/"/>
    <url>/2020/12/25/go/</url>
    
    <content type="html"><![CDATA[<h1 id="Go语言"><a href="#Go语言" class="headerlink" title="Go语言"></a>Go语言</h1><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><pre><code>1. 每个 Go 程序都是由包构成的。程序从 main 包开始运行。本程序通过导入路径 &quot;fmt&quot; 来使用它</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><pre><code>2. 此代码用圆括号组合了导入，这是“分组”形式的导入语句。也可以编写多个导入语句，例如：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math&quot;</span><br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><pre><code>1. var 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。2. 变量声明可以包含初始值，每个变量对应一个。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">var</span> c, python, java <span class="hljs-keyword">bool</span><br><span class="hljs-keyword">var</span> i, j <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span><br>fmt.Println(i, c, python, java)<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>3. 短变量声明：在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i, j <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>k := <span class="hljs-number">3</span><br>c, python, java := <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;no!&quot;</span><br>fmt.Println(i, j, k, c, python, java)<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>4. 基本类型：boolstringint  int8  int16  int32  int64uint uint8 uint16 uint32 uint64 uintptrbyte // uint8 的别名rune // int32 的别名    // 表示一个 Unicode 码点float32 float64complex64 complex1285. 常量：常量的声明与变量类似，只不过是使用 const 关键字。常量可以是字符、字符串、布尔值或数值。常量不能用 := 语法声明。</code></pre><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a><strong>for</strong></h3><pre><code>1. Go 只有一种循环结构：for 循环。2. 基本的 for 循环由三部分组成，它们用分号隔开：    初始化语句：在第一次迭代前执行    条件表达式：在每次迭代前求值    后置语句：在每次迭代的结尾执行</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>sum += i<br>&#125;<br>fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>3. 去掉分号的for循环就成了while循环(go语言中没有while循环)</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sum := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> sum &lt; <span class="hljs-number">1000</span> &#123;<br>sum += sum<br>&#125;<br>fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if"><a href="#if" class="headerlink" title="if"></a><strong>if</strong></h3><pre><code>同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。该语句声明的变量作用域仅在 if 之内。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pow</span><span class="hljs-params">(x, n, lim <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span> &#123;<br><span class="hljs-keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;<br><span class="hljs-keyword">return</span> v<br>&#125;<br><span class="hljs-keyword">return</span> lim<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<br>pow(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>),<br>pow(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">20</span>),<br>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>1. 函数可以没有参数或接受多个参数。其声明格式为：func FunName(arg1 Type1, arg2 Type2, ...) Type &#123;&#125;,例如以下的add函数</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>2. 当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。即 x int, y int 可以写成x, y int 3. 函数可以返回任意数量的返回值。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Swap</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> y, x<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><pre><code>1. go语言中的指针也是保存了变量的内存地址，零值为nil。2. 类型*T 是指向T类型的指针。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *<span class="hljs-keyword">int</span> <span class="hljs-comment">// 指向int型变量的指针</span><br></code></pre></td></tr></table></figure><pre><code>3. &amp; 取地址符号4. * 解引用符号</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">42</span><br>p = &amp;i<br>*p = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>go 没有指针运算</strong></p><h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><pre><code>1. go 语言没有类2. 结构体就是由一个字段组成，例如：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    X <span class="hljs-keyword">int</span><br>    Y <span class="hljs-keyword">int</span><br>&#125; <br><br></code></pre></td></tr></table></figure><pre><code>3. 结构体字段可以用.来访问。比如有个结构体变量p，可以用p.X访问X变量。4. 结构体指针访问结构体字段，比如有个结构体指针变量p，可以用(*p).X访问X变量,也可以用p.X进行隐式间接访问。5. 结构体文法，直接列出字段的值来新分配一个结构体。使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）特殊的前缀 &amp; 返回一个指向结构体的指针。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>v1 = Vertex&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;  <span class="hljs-comment">// 创建一个 Vertex 类型的结构体</span><br>v2 = Vertex&#123;X: <span class="hljs-number">1</span>&#125;  <span class="hljs-comment">// Y:0 被隐式地赋予</span><br>v3 = Vertex&#123;&#125;      <span class="hljs-comment">// X:0 Y:0</span><br>p  = &amp;Vertex&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125; <span class="hljs-comment">// 创建一个 *Vertex 类型的结构体（指针）</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(v1, p, v2, v3)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>1. var name [n]T 表示拥有n个T类型的数组</code></pre><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><pre><code>1. 类型 []T 表示一个元素类型为 T 的切片。2. 可以用短变量声明一个切片，例如：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><pre><code>3. 可以用make函数创建切片，例如</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">//创建一个3个元素，容量为5的切片</span><br>s := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><pre><code>4. 切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a[low : high] <span class="hljs-comment">//左闭右开区间</span><br></code></pre></td></tr></table></figure><pre><code>5. 切片拥有 长度 和 容量。切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。6. 向切片追加元素：append 函数</code></pre><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><pre><code>1. for 循环的 range 形式可遍历切片或映射。 当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> pow = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">128</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> pow &#123;<br>fmt.Printf(<span class="hljs-string">&quot;2**%d = %d\n&quot;</span>, i, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>2. 可以将下标或值赋予 _ 来忽略它。</code></pre><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><pre><code>1. map的声明为：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m <span class="hljs-keyword">map</span>[Type1]Type2 <span class="hljs-comment">// 将类型Type1 映射到Type2中</span><br></code></pre></td></tr></table></figure><pre><code>2. make 函数会返回给定类型的映射，并将其初始化备用。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>m[<span class="hljs-string">&quot;Bell Labs&quot;</span>] = <span class="hljs-number">1</span><br>fmt.Println(m[<span class="hljs-string">&quot;Bell Labs&quot;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><pre><code>1. 方法就是一类带特殊的 接收者 参数的函数。方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。例如函数add：</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-keyword">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> &#123;<br><span class="hljs-keyword">return</span> v.X + v.Y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>fmt.Println(v.Abs())<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><pre><code>接口类型 是由一组方法签名定义的集合。接口类型的变量可以保存任何实现了这些方法的值。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><span class="hljs-keyword">type</span> Abser <span class="hljs-keyword">interface</span> &#123;<br>Abs() <span class="hljs-keyword">float64</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a Abser<br>f := MyFloat(-math.Sqrt2)<br>v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>a = f  <span class="hljs-comment">// a MyFloat 实现了 Abser</span><br>a = &amp;v <span class="hljs-comment">// a *Vertex 实现了 Abser</span><br>fmt.Println(a.Abs())<br>&#125;<br><span class="hljs-keyword">type</span> MyFloat <span class="hljs-keyword">float64</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f MyFloat)</span> <span class="hljs-title">Abs</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> &#123;<br><span class="hljs-keyword">if</span> f &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">float64</span>(-f)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">float64</span>(f)<br>&#125;<br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-keyword">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span> <span class="hljs-title">Abs</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重建二叉树</title>
    <link href="/2020/12/21/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/12/21/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树</a></h2><pre><code>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。二叉树前序遍历：[根结点 左孩子 右孩子]二叉树中序遍历：[左孩子 根节点 右孩子]思路：因此首先需要从二叉树的前序遍历中找到根结点，然后通过中序遍历找到左子树和右子树。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    id1((根节点))<br>    id2((左子树))<br>    id3((右子树))<br><br>    id1--&gt;id2<br>    id1--&gt;id3<br><br></code></pre></td></tr></table></figure><pre><code>因此只要将根节点找到，然后分别计算出左子树结点个数和右子树结点个数，然后分别递归即可。例如有二叉树的前序遍历和中序遍历如下所示：前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]</code></pre><ol><li><p>因此一开始可以得到根节点为3，左子树为[9]，右子树为[15,20,7],如下图所示，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    id1((3))<br>    id2((9))<br>    id3((15,20,7))<br>    id1--&gt;id2<br>    id1--&gt;id3<br></code></pre></td></tr></table></figure></li><li><p>然后再递归右子树，得到根节点为20, 左孩子和有孩子分别为15和7，如下图所示</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD<br>    id1((3))<br>    id2((9))<br>    id3((20))<br>    id4((15))<br>    id5((7))<br>    id1--&gt;id2<br>    id1--&gt;id3<br>    id3--&gt;id4<br>    id3--&gt;id5<br></code></pre></td></tr></table></figure><ol start="3"><li>在递归过程中需要记录根节点在中序遍历中的下标，得到根结点下标后，就可以得到<br>左右子树的结点数量大小。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.size(); i++) &#123;<br>    m[inorder[i]] = i;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>计算左右子树的结点大小<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> left = index - is;<br><span class="hljs-keyword">int</span> right = ie - index;<br></code></pre></td></tr></table></figure></li></ol><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>ps</td><td>前序遍历左边界</td></tr><tr><td>pe</td><td>前序遍历右边界</td></tr><tr><td>is</td><td>中序遍历左边界</td></tr><tr><td>ie</td><td>中序遍历右边界</td></tr></tbody></table><p>5.当计算完左右子树的结点大小后，需要计算左右子树边界问题</p><table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>index</td><td>根节点下标</td></tr><tr><td>ps+1</td><td>前序遍历左子树的左边界</td></tr><tr><td>ps+left</td><td>前序遍历左子树的右边界</td></tr><tr><td>is</td><td>中序遍历左子树左边界</td></tr><tr><td>index-1</td><td>中序遍历左子树右边界</td></tr><tr><td>pe - right + 1</td><td>前序遍历右子树的左边界</td></tr><tr><td>pe</td><td>前序遍历右子树的右边界</td></tr><tr><td>index + 1</td><td>中序遍历右子树左边界</td></tr><tr><td>ie</td><td>中序遍历右子树右边界</td></tr></tbody></table><ol start="6"><li>代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.size(); i++) &#123;<br>            m[inorder[i]] = i;<br>        &#125;<br>        TreeNode* root = build(preorder, <span class="hljs-number">0</span>, preorder.size() - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.size() - <span class="hljs-number">1</span>, m);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; pre, <span class="hljs-keyword">int</span> ps, <span class="hljs-keyword">int</span> pe, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-keyword">int</span> is, <span class="hljs-keyword">int</span> ie, <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; m)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ps &gt; pe) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125; <br>        <span class="hljs-keyword">int</span> value = pre[ps];<br>        TreeNode* root = <span class="hljs-keyword">new</span> TreeNode(value);<br>        <span class="hljs-keyword">if</span> (ps == pe) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> index = m[value];<br>            <span class="hljs-keyword">int</span> left = index - is;<br>            <span class="hljs-keyword">int</span> right = ie - index;<br>            root-&gt;left = build(pre, ps + <span class="hljs-number">1</span>, ps + left, inorder, is, index - <span class="hljs-number">1</span>, m);<br>            root-&gt;right = build(pre, pe - right + <span class="hljs-number">1</span>, pe, inorder, index + <span class="hljs-number">1</span>, ie, m);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组查找</title>
    <link href="/2020/12/20/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/"/>
    <url>/2020/12/20/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">二维数组中的查找</a></h2><pre><code>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路：从左下角开始查找，当matrix[i][j] &gt; target，则向上查；当matrix[i][j] &lt; target，则向右查找。</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    i := <span class="hljs-built_in">len</span>(matrix) - <span class="hljs-number">1</span>;<br>    j := <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> ; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]);  &#123;<br>        <span class="hljs-keyword">if</span> matrix[i][j] &gt; target &#123;<br>            i--;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> matrix[i][j] &lt; target &#123;<br>            j++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>找不同</title>
    <link href="/2020/12/18/%E6%89%BE%E4%B8%8D%E5%90%8C/"/>
    <url>/2020/12/18/%E6%89%BE%E4%B8%8D%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="找不同"><a href="#找不同" class="headerlink" title="找不同"></a><a href="https://leetcode-cn.com/problems/find-the-difference/">找不同</a></h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定两个字符串 s 和 <span class="hljs-built_in">t</span>，它们只包含小写字母。<br>字符串 <span class="hljs-built_in">t</span> 由字符串 s 随机重排，然后在随机位置添加一个字母。<br>请找出在 <span class="hljs-built_in">t</span> 中被添加的字母。<br></code></pre></td></tr></table></figure><ul><li>c++<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">findTheDifference</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>&amp; c : t) &#123;<br>            sum += c;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span>&amp; c : s) &#123;<br>            sum -= c;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li>go<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTheDifference</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>, t <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">byte</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> res <span class="hljs-keyword">byte</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(t); i++ &#123;<br>        res += t[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        res -= s[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串压缩</title>
    <link href="/2020/12/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"/>
    <url>/2020/12/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串压缩"><a href="#字符串压缩" class="headerlink" title="字符串压缩"></a><a href="https://leetcode-cn.com/problems/compress-string-lcci/">字符串压缩</a></h1><pre><code>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母(a至z)。输入：&quot;aabcccccaaa&quot;输出：&quot;a2b1c5a3&quot;</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">compressString</span><span class="hljs-params">(<span class="hljs-built_in">string</span> S)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (S == <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">return</span> S;<br>        <span class="hljs-built_in">string</span> result;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">char</span> c = S[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">1</span>; i &lt; S.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (c == S[i]) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.push_back(c);<br>                result += to_string(count);<br>                count = <span class="hljs-number">1</span>;<br>                c = S[i];<br>            &#125;<br>        &#125;<br>        result.push_back(c);<br>        result += to_string(count);<br>        <span class="hljs-keyword">return</span> result.size() &lt; S.size() ? result : S;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异位词分组</title>
    <link href="/2020/12/14/%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <url>/2020/12/14/%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/">字母异位词分组</a></h1><pre><code>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出:[[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;bat&quot;]]</code></pre><p><strong>思路</strong>：调库就完了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; result;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; strs.size(); i++) &#123;<br>            <span class="hljs-built_in">string</span> s = strs[i];<br>            sort(s.begin(), s.end());<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; t = m[s];<br>            t.push_back(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = m.begin(); i != m.end(); i++) &#123;<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; temp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>&amp; index : i-&gt;second) &#123;<br>                temp.push_back(strs[index]);<br>            &#125;<br>            result.push_back(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并k个有序链表</title>
    <link href="/2020/12/14/mergeKLists/"/>
    <url>/2020/12/14/mergeKLists/</url>
    
    <content type="html"><![CDATA[<h1 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表</a></h1><pre><code>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>使用分治法思想，假设有l1,l2,l3,l4四个链表，首先l1和l2合并成为l12, l3和l4合并成l34，然后l12和l34合并成l。具体的代码如下所示：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">return</span> lists[l];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="hljs-number">1</span>, r));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode* tail = head;<br>        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;<br>                tail-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br>        <br>        tail-&gt;next = (l1 == <span class="hljs-literal">NULL</span> ? l2 : l1);<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unorder_map</title>
    <link href="/2020/12/14/unorder_map/"/>
    <url>/2020/12/14/unorder_map/</url>
    
    <content type="html"><![CDATA[<h1 id="unorder-map"><a href="#unorder-map" class="headerlink" title="unorder_map"></a>unorder_map</h1><p>unordered_map，它是一个关联容器，内部采用的是hash表结构，拥有快速检索的功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++ 11 新标准</title>
    <link href="/2020/12/14/c++11/"/>
    <url>/2020/12/14/c++11/</url>
    
    <content type="html"><![CDATA[<h1 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h1><h2 id="1-新类型"><a href="#1-新类型" class="headerlink" title="1 新类型"></a>1 新类型</h2><pre><code>1.1 c++11 新增了类型long long 和unsigned long long，支持64位整型。</code></pre><h2 id="2-初始化方式"><a href="#2-初始化方式" class="headerlink" title="2 初始化方式"></a>2 初始化方式</h2><pre><code>2.1 初始化方式，使用初始化列表时，可以添加等号(=)，也可以不用： int x = &#123;5&#125;, double y&#123;5&#125;。初始化列表可用于new 表达式中， int *arr = new int[5]&#123;2 0 0 0 0&#125;。2.2 c++ 11 提供了std::initializer_list,可以用于作构造函数的参数，如：vector&lt;int&gt; a1&#123;10&#125;;vector&lt;int&gt; a2&#123;10&#125;;</code></pre><h2 id="3-声明"><a href="#3-声明" class="headerlink" title="3 声明"></a>3 声明</h2><pre><code>3.1 关键字auto，用于实现自动类型推断，要求进行显示初始化，例如：auto m = 112; // type intauto pt = &amp;m; // pt is type int*3.2 关键字decltype,将变量的类型声明为表达式指定的类型。下面的语句含义是：让y的类型与x的相同，x是一个表达式。decltype(x) y例如：double x; int n;decltype(x*n) q; //将q的里欸选哪个声明为与x*n相同,double3.3 返回类型后置c++11 新增一种函数声明语法：在函数名和参数列表后面指定返回类型：double f1(double, int); // tradictional syntaxauto f2(double, int) -&gt; double;例如：template&lt;typename T, typename U&gt;auto eff(T t, U u) -&gt; decltype(T*U)&#123;&#125;解决了在编译器遇到eff的参数列表前，T和U都还不在作用域内，因此必须在参数列表后使用decltype。3.4 模板别名: using =c++ 11提供了另一种新的创建别名的语法：using itType = std::vector&lt;std::string&gt;::iterator;</code></pre><h2 id="4-Lambda-函数"><a href="#4-Lambda-函数" class="headerlink" title="4 Lambda 函数"></a>4 Lambda 函数</h2><pre><code>语法：[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125;capture list：用于捕获外部变量param list:参数列表return type: 返回类型mutable：用来说用是否可以修改捕获的变量exception：异常设定常见写法：[capture list] (params list) -&gt; return type &#123; function body &#125;[capture list] (params list)&#123; function body &#125;[capture list] &#123; function body &#125;</code></pre><h2 id="5-右值引用（2021-3-5更新）"><a href="#5-右值引用（2021-3-5更新）" class="headerlink" title="5 右值引用（2021-3-5更新）"></a>5 右值引用（2021-3-5更新）</h2>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>commonNode</title>
    <link href="/2020/12/12/commonNode/"/>
    <url>/2020/12/12/commonNode/</url>
    
    <content type="html"><![CDATA[<h1 id="输入两个链表，找出它们的第一个公共节点。"><a href="#输入两个链表，找出它们的第一个公共节点。" class="headerlink" title="输入两个链表，找出它们的第一个公共节点。"></a><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">输入两个链表，找出它们的第一个公共节点。</a></h1><p><img src="https://i.loli.net/2021/03/05/kLriNCpxcoh76QU.png" alt="1.PNG"><br><strong>思路</strong>：首先算出链表A和链表B各自的长度，然后作差求得两者长度之差，假设差为k，让长的链表先走k步，然后两个链表同时走，直到遇到公共节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = length(headA);<br>        <span class="hljs-keyword">int</span> n = length(headB);<br>        <span class="hljs-keyword">if</span> (m &gt;= n) &#123;<br>            <span class="hljs-keyword">int</span> k = m - n;<br>            <span class="hljs-keyword">return</span> getCommon(headA, headB, k);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> k = n - m;<br>            <span class="hljs-keyword">return</span> getCommon(headB, headA, k);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">getCommon</span><span class="hljs-params">(ListNode* headA, ListNode* headB, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        ListNode* p = headA;<br>        <span class="hljs-keyword">for</span> (; p &amp;&amp; i &lt; k; i++, p = p-&gt;next);<br>        <span class="hljs-keyword">while</span> ((p &amp;&amp; headB) &amp;&amp; (p != headB)) &#123;<br>            p = p-&gt;next;<br>            headB = headB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        ListNode* p = node;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            p = p-&gt;next;<br>            length++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>subArraySum</title>
    <link href="/2020/12/06/subArraySum/"/>
    <url>/2020/12/06/subArraySum/</url>
    
    <content type="html"><![CDATA[<h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和</a></h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p><strong>设dp[i]是数组中以第i个数结尾的和，则dp[i] 与dp[i-1]有关，若dp[i-1]小于0，则dp[i]=num[i]；否则dp[i]=dp[i-1]+num[i]，因此有动态方程：</strong></p><p>$$<br>dp[i] = num[i]+ max(dp[i],0)<br>$$</p><p><strong>然后求dp数组中的最大值，即可得到子数组的最大和</strong></p><p><strong>然而我们需要的dp数组中的最大值，不需要其他值，因此dp数组中其他数是多余的，只需要一个变量即可，具体代码如下所示，此时时间复杂度为O(n),空间复杂度为O(1)。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0xf0000000</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0xf0000000</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            m = max(m, <span class="hljs-number">0</span>) + nums[i];<br>            ans = max(ans, m);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>printTree</title>
    <link href="/2020/12/06/printTree/"/>
    <url>/2020/12/06/printTree/</url>
    
    <content type="html"><![CDATA[<h1 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树</a></h1><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p><strong>BFS，层次遍历，利用index记录每一层的个数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>        <span class="hljs-keyword">if</span> (root) &#123;<br>            q.push(root);<br>            <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v&#123;&#125;;<br>                <span class="hljs-keyword">int</span> level = q.size(); <span class="hljs-comment">//记录当前层的结点个数</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>                    TreeNode* tmp = q.front();<br>                    q.pop();<br>                    v.push_back(tmp-&gt;val);<br>                    <span class="hljs-keyword">if</span> (tmp-&gt;left) &#123;<br>                        q.push(tmp-&gt;left);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (tmp-&gt;right) &#123;<br>                        q.push(tmp-&gt;right);<br>                    &#125;<br>                &#125;<br>                ans.push_back(v);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>countOne</title>
    <link href="/2020/12/06/countOne/"/>
    <url>/2020/12/06/countOne/</url>
    
    <content type="html"><![CDATA[<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a></h1><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p><strong>思路</strong>:利用‘与’运行，因为0 &amp; 1 = 0； 1 &amp; 1 = 1。例如有数1101，然后用1101 &amp; 1 = 1，然后将1101右移一位得到0110，再与1进行‘与’运行，将结果全部相加就可以得到1的个数的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            res += (n &amp; <span class="hljs-number">1</span>);<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linklist</title>
    <link href="/2020/12/04/linklist/"/>
    <url>/2020/12/04/linklist/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-关于链表的题"><a href="#Leetcode-关于链表的题" class="headerlink" title="Leetcode 关于链表的题"></a>Leetcode 关于链表的题</h1><ol><li>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></li></ol><p>思路:设置双指针，slow和fast, 首先让fast指针先走k步，然后slow指针和fast一起走，直到fast指针指向最后一个元素，此时slow指向倒数第k个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; fast; i++, fast = fast-&gt;next);<br>        <span class="hljs-keyword">while</span> (slow &amp;&amp; fast) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">删除链表的节点</a></li></ol><p>输入: head = [4,5,1,9], val = 5</p><p>输出: [4,1,9]</p><p>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        pre-&gt;next = head;<br>        ListNode* p = pre-&gt;next;<br>        ListNode* p2 = pre;<br>        <span class="hljs-keyword">for</span> (; p &amp;&amp; p-&gt;val != val; p = p-&gt;next, p2 = p2-&gt;next);<br>        p2-&gt;next = p-&gt;next;<br>        <span class="hljs-keyword">return</span> pre-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reverseLinkList</title>
    <link href="/2020/12/02/reverseLinkList/"/>
    <url>/2020/12/02/reverseLinkList/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</a></p><pre><code>输入：head = [1,3,2]输出：[2,3,1]</code></pre><p><strong>思路</strong>：首先将链表进行原地逆转。<br>例如有链表：dummy-&gt;1-&gt;3-&gt;2; 首先设置两个临时变量pre, p分别指向值为1的节点和值为3的节点。然后进行循环，修改指针：</p><pre><code>第一次循环：pre-&gt;next = p-&gt;next,即1-&gt;2,p-&gt;next = dummy-&gt;next;即3-&gt;1;dummy-&gt;next = p;即dummy-&gt;3-&gt;1-&gt;2;然后修改p指向值为2的节点第二次循环后就可以得到:dummy-&gt;2-&gt;3-&gt;1;</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            result.push_back(head-&gt;val);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        ListNode* dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        ListNode* pre = dummy-&gt;next;<br>        ListNode* p = pre-&gt;next;<br>        <span class="hljs-keyword">while</span> (pre-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>            pre-&gt;next = p-&gt;next;<br>            p-&gt;next = dummy-&gt;next;<br>            dummy-&gt;next = p;<br>            p = pre-&gt;next;<br>        &#125;<br>        p = dummy;<br>        p = p-&gt;next;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>            result.push_back(p-&gt;val);<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos</title>
    <link href="/2020/12/01/centos/"/>
    <url>/2020/12/01/centos/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一下linux常用操作"><a href="#记录一下linux常用操作" class="headerlink" title="记录一下linux常用操作"></a>记录一下linux常用操作</h1><h2 id="centos-8-上的换源"><a href="#centos-8-上的换源" class="headerlink" title="centos 8 上的换源"></a>centos 8 上的换源</h2><pre><code> 1 使用命令cd /etc/yum.repos.d, 进入源文件所在目录. 2 然后将之前的源文件备份一下，cp CentOS-Base.repo CentOS-Base.repo.back 3 再使用wget下载源文件，wget -O CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo 4 yum makecache 5 yum update</code></pre><h2 id="记录常见错误，以及解决方法"><a href="#记录常见错误，以及解决方法" class="headerlink" title="记录常见错误，以及解决方法"></a>记录常见错误，以及解决方法</h2><h3 id="常见错误1，xxx不在sudoers文件中"><a href="#常见错误1，xxx不在sudoers文件中" class="headerlink" title="常见错误1，xxx不在sudoers文件中"></a>常见错误1，xxx不在sudoers文件中</h3><pre><code>例如在shell终端输入sudo yum install vim， 此时报错字样为：henry is not in the sudoers file.  This incident will be reported.解决办法：1.首先进入root用户下，在shell终端输入su，然后输入用户密码。2.添加sudo文件的写权限,命令是:chmod u+w /etc/sudoers3.编辑sudoers文件，命令vim /etc/sudoers4.找到这行 root ALL=(ALL) ALL,在他下面添加xxx ALL=(ALL) ALL (这里的xxx是你的用户名)完成！</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>binarySearch</title>
    <link href="/2020/12/01/binarySearch/"/>
    <url>/2020/12/01/binarySearch/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><pre><code>1. 在有序数组nums中查找值为target的下标，查找失败返回-1</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><pre><code>2. 在有序数组nums中查找都一个比target大的数,失败返回</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> ans = nums.size();<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>            <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>3. 在有序数组nums中查找都target第一次出现和最后一次出现的位置,失败返回[-1,-1].输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]</code></pre><p><strong>思路</strong>: 首先先用二分查找找到第一个target出现的位置left，然后查找第一个大于target的位置right，然后用right-1就是target出现最后一次的位置，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = binarySearch(nums, target, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">int</span> right = binarySearch(nums, target, <span class="hljs-literal">false</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (left &lt;= right &amp;&amp; right &lt; nums.size()  &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &#123;left, right&#125;; <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">bool</span> flag)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.size() - <span class="hljs-number">1</span> ;<br>        <span class="hljs-keyword">int</span> ans = nums.size();<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target || (flag &amp;&amp; nums[mid] &gt;= target)) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                ans = mid;<br>            &#125; <span class="hljs-keyword">else</span>  &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fourSumCount</title>
    <link href="/2020/11/29/fourSumCount/"/>
    <url>/2020/11/29/fourSumCount/</url>
    
    <content type="html"><![CDATA[<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a><a href="https://leetcode-cn.com/problems/4sum-ii/">四数之和</a></h2><pre><code>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</code></pre><p><strong>思路</strong><br>使用散列表，先将数组A和B中任意两个数之和放入哈希映射中，每一个键是A[i]+B[j],值是对应的次数。然后在数组C和D之间相对应的建，当遇到-(C[k]+D[l])，则答案加1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; B, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; C, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; D)</span> </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; count;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;u : A) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;v : B) &#123;<br>                ++count[u+v];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;u : C) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;v : D) &#123;<br>                <span class="hljs-keyword">if</span> (count.count(-u-v))<br>                    ret += count[-(u+v)];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>convex-optimization</title>
    <link href="/2020/11/27/convex-opt/"/>
    <url>/2020/11/27/convex-opt/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h1><h2 id="convex-set"><a href="#convex-set" class="headerlink" title="convex set"></a>convex set</h2><h3 id="2-1-Affine-and-convex-set"><a href="#2-1-Affine-and-convex-set" class="headerlink" title="2.1 Affine and convex set"></a>2.1 Affine and convex set</h3><h4 id="2-1-1-Lines-and-line-segment"><a href="#2-1-1-Lines-and-line-segment" class="headerlink" title="2.1.1 Lines and line segment"></a>2.1.1 Lines and line segment</h4><h4 id="2-1-2-Affine-sets"><a href="#2-1-2-Affine-sets" class="headerlink" title="2.1.2 Affine sets"></a>2.1.2 Affine sets</h4><p>​    A set $C \in R^n$ is <strong>affine</strong> if the line through any two distinct points in C lies in C. We refer to a point of the form<br>$ \theta_1x_1+\dots+\theta_k x_k$, where $\theta_1+\dots+\theta_k=1 $, as an affine combination of points $x_1,\dots,x_k$. If C is an affine set, $x_1,\dots,x_k \in C$ and$\theta_1+\dots+\theta_k=1$,then the point $\theta_1x_1+\dots+\theta_k x_k$ also belongs to C.</p><p>​    The set of all affine combinations of points in some $C\subseteq R^n$ is called the <strong>affine hull（仿射包）</strong>of C, and denoted <strong>aff</strong> C:<br>$$<br>aff\quad C = {\theta_1x_1+\dots+\theta_k x_k | x_1, \dots,x_k \in C, \theta_1+\dots+\theta_k=1}<br>$$<br>The affine hull is the smallest affine set that contains C.</p><h4 id="2-1-3-Affine-dimension-and-relative-interior"><a href="#2-1-3-Affine-dimension-and-relative-interior" class="headerlink" title="2.1.3 Affine dimension and relative interior"></a>2.1.3 Affine dimension and relative interior</h4><p>​    The <strong>affine dimension</strong> of a set C as the dimension of its affine hull.</p><p>​    The <strong>relative interior</strong> of a set C is denoted <strong>relint C</strong>,as its interior relative to <strong>aff C</strong>:<br>$$<br>relint \quad C={x\in C|B(x,r) \cap aff \quad C \subseteq C \quad for \quad some \quad r&gt;0}<br>$$<br>where $B(r,x)={ y| ||y-x|| \le r}$.</p><p>​    The <strong>relative boundary</strong> of a set C as cl C \ relint C, where cl C is the closure of C.</p><h4 id="2-1-4-Convex-set"><a href="#2-1-4-Convex-set" class="headerlink" title="2.1.4 Convex set"></a>2.1.4 Convex set</h4><p>​    A set C is convex if the line segment between any two point in C lies in C. i.e., if any $x_1,x_2 \in C$ and any $\theta \in [0,1]$, we have  $\theta x_1+(1-\theta)x_2 \in C$.</p><p>​    We call a point of the from $\theta_1x_1+\dots+\theta_k x_k$, where $\theta_1+\dots+\theta_k=1$ and $\theta_i \ge 0, i=1,\dots,k$, a convex combination of the points  $x_1,\dots,x_k$.</p><p>​    The convex hull of a set C,denoted <strong>conv C</strong>, is the set of all convex combinations  of points in C：</p><p>$$<br>convC={\theta_1x_1+\dots+\theta_k x_k | x_1, \dots,x_k \in C, \theta_1+\dots+\theta_k=1, \theta_i \ge 0, i=1,\dots,k}<br>$$</p><h4 id="2-1-5-Cones"><a href="#2-1-5-Cones" class="headerlink" title="2.1.5 Cones"></a>2.1.5 Cones</h4><p>​    A set C is called a cone, if for every $x \in C$  and $\theta \ge 0$,we have $\theta x \in C$. A set C is convex cone if it is convex and a cone.</p><h3 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h3><h4 id="2-2-1-Hyperplanes-and-halfspaces"><a href="#2-2-1-Hyperplanes-and-halfspaces" class="headerlink" title="2.2.1 Hyperplanes and halfspaces"></a>2.2.1 Hyperplanes and halfspaces</h4><p>​    A hyperplane is a set of the form ${x|a^Tx=b}$, where $a\in R^n,a\ne 0$ and $b\in R$. It also has the form ${x|a^T(x-x_0)=0}$, where $x_0$is any point in the hyperplane(any point satisfies $a^Tb=0$).</p><h4 id="2-2-2-Euclidean-balls-and-ellipsoids"><a href="#2-2-2-Euclidean-balls-and-ellipsoids" class="headerlink" title="2.2.2 Euclidean balls and ellipsoids"></a>2.2.2 Euclidean balls and ellipsoids</h4><p>​    A ball in $R^n$ has the form $B(x_c,r)={x| \quad\left|x-x_c\right|_2\le r  }={x| (x-x_c)^T(x-x_c) \le r^2}$</p><h4 id="2-2-3-Norm-balls-and-norm-cones"><a href="#2-2-3-Norm-balls-and-norm-cones" class="headerlink" title="2.2.3 Norm balls and norm cones"></a>2.2.3 Norm balls and norm cones</h4><p>​    A norm ball associated with the norm $\left |·\right |$ is the set ${x | \left|x-x_c\right| \le r}$.</p><p>​    A norm cones associated with the norm  $\left |·\right |$ is the set ${(x,t) | \left|x\right| \le t}$.</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长字串</title>
    <link href="/2020/11/26/first/"/>
    <url>/2020/11/26/first/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</a></p><p><strong>输入实例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度 3</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>思路</strong></p><p>​    采用滑动窗口的思想，设置两个指针，一个指针<strong>i</strong>指向左边，一个指针<strong>rk</strong> 指向右边，此时最长的字符字串为<strong>s[i]s[i+1]…s[rk]</strong></p><p>，此时长度为<strong>rk-i+1</strong>。具体思路如下所示:</p><ol><li><p>abcabcbb,首先i指针指向第一个字符，可以得到最长的无重复字符字串为(abc)abcbb, ()表示最长的无重复字符字串。</p></li><li><p>abcabcbb a(bca)bcbb</p></li><li><p>abcabcbb,ab(cab)cbb</p></li><li><p>abcabcbb,abc(abc)bb</p></li><li><p>abcabcbb,abca(bc)bb</p></li><li><p>abcabcbb,abcab(cb)b</p></li><li><p>abcabcbb,abcabcb(b)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">char</span>&gt; check;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">int</span> rk = <span class="hljs-number">-1</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                check.erase(s[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (rk + <span class="hljs-number">1</span> &lt; s.size() &amp;&amp; check.count(s[rk + <span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>)&#123;<br>                check.insert(s[rk + <span class="hljs-number">1</span>]);<br>                ++rk;<br>            &#125;<br>            res = max(res, rk - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
