<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>异位词分组</title>
    <link href="/2020/12/14/%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <url>/2020/12/14/%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="字母异位词分组"><a href="https://leetcode-cn.com/problems/group-anagrams/">字母异位词分组</a></h1><pre><code>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出:[[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;bat&quot;]]</code></pre><p><strong>思路</strong>：调库就完了 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; result;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; strs.size(); i++) &#123;<br>            <span class="hljs-built_in">string</span> s = strs[i];<br>            sort(s.begin(), s.end());<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; t = m[s];<br>            t.push_back(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = m.begin(); i != m.end(); i++) &#123;<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; temp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>&amp; index : i-&gt;second) &#123;<br>                temp.push_back(strs[index]);<br>            &#125;<br>            result.push_back(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并k个有序链表</title>
    <link href="/2020/12/14/mergeKLists/"/>
    <url>/2020/12/14/mergeKLists/</url>
    
    <content type="html"><![CDATA[<h1 id="合并k个升序链表"><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并K个升序链表</a></h1><pre><code>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></pre><h2 id="思路">思路</h2><pre><code>使用分治法思想，假设有l1,l2,l3,l4四个链表，首先l1和l2合并成为l12, l3和l4合并成l34，然后l12和l34合并成l。具体的代码如下所示：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, lists.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">return</span> lists[l];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid + <span class="hljs-number">1</span>, r));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode* tail = head;<br>        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;<br>                tail-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                tail-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br>        <br>        tail-&gt;next = (l1 == <span class="hljs-literal">NULL</span> ? l2 : l1);<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unorder_map</title>
    <link href="/2020/12/14/unorder_map/"/>
    <url>/2020/12/14/unorder_map/</url>
    
    <content type="html"><![CDATA[<h1 id="unorder_map">unorder_map</h1><p>unordered_map，它是一个关联容器，内部采用的是hash表结构，拥有快速检索的功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++ 11 新标准</title>
    <link href="/2020/12/14/c++11/"/>
    <url>/2020/12/14/c++11/</url>
    
    <content type="html"><![CDATA[<h1 id="c11">C++11</h1><h2 id="新类型">1 新类型</h2><pre><code>1.1 c++11 新增了类型long long 和unsigned long long，支持64位整型。</code></pre><h2 id="初始化方式">2 初始化方式</h2><pre><code>2.1 初始化方式，使用初始化列表时，可以添加等号(=)，也可以不用： int x = &#123;5&#125;, double y&#123;5&#125;。初始化列表可用于new 表达式中， int *arr = new int[5]&#123;2 0 0 0 0&#125;。2.2 c++ 11 提供了std::initializer_list,可以用于作构造函数的参数，如：vector&lt;int&gt; a1&#123;10&#125;;vector&lt;int&gt; a2&#123;10&#125;;</code></pre><h2 id="声明">3 声明</h2><pre><code>3.1 关键字auto，用于实现自动类型推断，要求进行显示初始化，例如：auto m = 112; // type intauto pt = &amp;m; // pt is type int*3.2 关键字decltype,将变量的类型声明为表达式指定的类型。下面的语句含义是：让y的类型与x的相同，x是一个表达式。decltype(x) y例如：double x; int n;decltype(x*n) q; //将q的里欸选哪个声明为与x*n相同,double3.3 返回类型后置c++11 新增一种函数声明语法：在函数名和参数列表后面指定返回类型：double f1(double, int); // tradictional syntaxauto f2(double, int) -&gt; double;例如：template&lt;typename T, typename U&gt;auto eff(T t, U u) -&gt; decltype(T*U)&#123;&#125;解决了在编译器遇到eff的参数列表前，T和U都还不在作用域内，因此必须在参数列表后使用decltype。3.4 模板别名: using =c++ 11提供了另一种新的创建别名的语法：using itType = std::vector&lt;std::string&gt;::iterator;</code></pre><h2 id="lambda-函数">4 Lambda 函数</h2><pre><code>语法：[capture list] (params list) mutable exception-&gt; return type &#123; function body &#125;capture list：用于捕获外部变量param list:参数列表return type: 返回类型mutable：用来说用是否可以修改捕获的变量exception：异常设定常见写法：[capture list] (params list) -&gt; return type &#123; function body &#125;[capture list] (params list)&#123; function body &#125;[capture list] &#123; function body &#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>commonNode</title>
    <link href="/2020/12/12/commonNode/"/>
    <url>/2020/12/12/commonNode/</url>
    
    <content type="html"><![CDATA[<h1 id="输入两个链表找出它们的第一个公共节点"><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">输入两个链表，找出它们的第一个公共节点。</a></h1><p><strong>思路</strong>：首先算出链表A和链表B各自的长度，然后作差求得两者长度之差，假设差为k，让长的链表先走k步，然后两个链表同时走，直到遇到公共节点。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = length(headA);<br>        <span class="hljs-keyword">int</span> n = length(headB);<br>        <span class="hljs-keyword">if</span> (m &gt;= n) &#123;<br>            <span class="hljs-keyword">int</span> k = m - n;<br>            <span class="hljs-keyword">return</span> getCommon(headA, headB, k);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> k = n - m;<br>            <span class="hljs-keyword">return</span> getCommon(headB, headA, k);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">getCommon</span><span class="hljs-params">(ListNode* headA, ListNode* headB, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        ListNode* p = headA;<br>        <span class="hljs-keyword">for</span> (; p &amp;&amp; i &lt; k; i++, p = p-&gt;next);<br>        <span class="hljs-keyword">while</span> ((p &amp;&amp; headB) &amp;&amp; (p != headB)) &#123;<br>            p = p-&gt;next;<br>            headB = headB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>        ListNode* p = node;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            p = p-&gt;next;<br>            length++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>subArraySum</title>
    <link href="/2020/12/06/subArraySum/"/>
    <url>/2020/12/06/subArraySum/</url>
    
    <content type="html"><![CDATA[<h1 id="连续子数组的最大和"><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">连续子数组的最大和</a></h1><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p><strong>设dp[i]是数组中以第i个数结尾的和，则dp[i] 与dp[i-1]有关，若dp[i-1]小于0，则dp[i]=num[i]；否则dp[i]=dp[i-1]+num[i]，因此有动态方程：</strong></p><p><span class="math display">\[dp[i] = num[i]+ max(dp[i],0)\]</span></p><p><strong>然后求dp数组中的最大值，即可得到子数组的最大和</strong></p><p><strong>然而我们需要的dp数组中的最大值，不需要其他值，因此dp数组中其他数是多余的，只需要一个变量即可，具体代码如下所示，此时时间复杂度为O(n),空间复杂度为O(1)。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0xf0000000</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0xf0000000</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) &#123;<br>            m = max(m, <span class="hljs-number">0</span>) + nums[i];<br>            ans = max(ans, m);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>printTree</title>
    <link href="/2020/12/06/printTree/"/>
    <url>/2020/12/06/printTree/</url>
    
    <content type="html"><![CDATA[<h1 id="从上到下打印二叉树"><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树</a></h1><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p><strong>BFS，层次遍历，利用index记录每一层的个数</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">queue</span>&lt;TreeNode*&gt; q;<br>        <span class="hljs-keyword">if</span> (root) &#123;<br>            q.push(root);<br>            <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>                <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v&#123;&#125;;<br>                <span class="hljs-keyword">int</span> level = q.size(); <span class="hljs-comment">//记录当前层的结点个数</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++) &#123;<br>                    TreeNode* tmp = q.front();<br>                    q.pop();<br>                    v.push_back(tmp-&gt;val);<br>                    <span class="hljs-keyword">if</span> (tmp-&gt;left) &#123;<br>                        q.push(tmp-&gt;left);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (tmp-&gt;right) &#123;<br>                        q.push(tmp-&gt;right);<br>                    &#125;<br>                &#125;<br>                ans.push_back(v);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>countOne</title>
    <link href="/2020/12/06/countOne/"/>
    <url>/2020/12/06/countOne/</url>
    
    <content type="html"><![CDATA[<h1 id="二进制中1的个数"><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a></h1><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p><strong>思路</strong>:利用‘与’运行，因为0 &amp; 1 = 0； 1 &amp; 1 = 1。例如有数1101，然后用1101 &amp; 1 = 1，然后将1101右移一位得到0110，再与1进行‘与’运行，将结果全部相加就可以得到1的个数的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            res += (n &amp; <span class="hljs-number">1</span>);<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linklist</title>
    <link href="/2020/12/04/linklist/"/>
    <url>/2020/12/04/linklist/</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-关于链表的题">Leetcode 关于链表的题</h1><ol type="1"><li>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。<a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></li></ol><p>思路:设置双指针，slow和fast, 首先让fast指针先走k步，然后slow指针和fast一起走，直到fast指针指向最后一个元素，此时slow指向倒数第k个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; fast; i++, fast = fast-&gt;next);<br>        <span class="hljs-keyword">while</span> (slow &amp;&amp; fast) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。<a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">删除链表的节点</a></li></ol><p>输入: head = [4,5,1,9], val = 5</p><p>输出: [4,1,9]</p><p>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        pre-&gt;next = head;<br>        ListNode* p = pre-&gt;next;<br>        ListNode* p2 = pre;<br>        <span class="hljs-keyword">for</span> (; p &amp;&amp; p-&gt;val != val; p = p-&gt;next, p2 = p2-&gt;next);<br>        p2-&gt;next = p-&gt;next;<br>        <span class="hljs-keyword">return</span> pre-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reverseLinkList</title>
    <link href="/2020/12/02/reverseLinkList/"/>
    <url>/2020/12/02/reverseLinkList/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</a></p><pre><code>输入：head = [1,3,2]输出：[2,3,1]</code></pre><p><strong>思路</strong>：首先将链表进行原地逆转。 例如有链表：dummy-&gt;1-&gt;3-&gt;2; 首先设置两个临时变量pre, p分别指向值为1的节点和值为3的节点。然后进行循环，修改指针：</p><pre><code>第一次循环：pre-&gt;next = p-&gt;next,即1-&gt;2,p-&gt;next = dummy-&gt;next;即3-&gt;1;dummy-&gt;next = p;即dummy-&gt;3-&gt;1-&gt;2;然后修改p指向值为2的节点第二次循环后就可以得到:dummy-&gt;2-&gt;3-&gt;1;</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reversePrint</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            result.push_back(head-&gt;val);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br><br>        ListNode* dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        ListNode* pre = dummy-&gt;next;<br>        ListNode* p = pre-&gt;next;<br>        <span class="hljs-keyword">while</span> (pre-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>            pre-&gt;next = p-&gt;next;<br>            p-&gt;next = dummy-&gt;next;<br>            dummy-&gt;next = p;<br>            p = pre-&gt;next;<br>        &#125;<br>        p = dummy;<br>        p = p-&gt;next;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>            result.push_back(p-&gt;val);<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos</title>
    <link href="/2020/12/01/centos/"/>
    <url>/2020/12/01/centos/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一下linux常用操作">记录一下linux常用操作</h1><h2 id="centos-8-上的换源">centos 8 上的换源</h2><pre><code> 1 使用命令cd /etc/yum.repos.d, 进入源文件所在目录. 2 然后将之前的源文件备份一下，cp CentOS-Base.repo CentOS-Base.repo.back 3 再使用wget下载源文件，wget -O CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo 4 yum makecache 5 yum update</code></pre><h2 id="记录常见错误以及解决方法">记录常见错误，以及解决方法</h2><h3 id="常见错误1xxx不在sudoers文件中">常见错误1，xxx不在sudoers文件中</h3><pre><code>例如在shell终端输入sudo yum install vim， 此时报错字样为：henry is not in the sudoers file.  This incident will be reported.解决办法：1.首先进入root用户下，在shell终端输入su，然后输入用户密码。2.添加sudo文件的写权限,命令是:chmod u+w /etc/sudoers3.编辑sudoers文件，命令vim /etc/sudoers4.找到这行 root ALL=(ALL) ALL,在他下面添加xxx ALL=(ALL) ALL (这里的xxx是你的用户名)完成！</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>binarySearch</title>
    <link href="/2020/12/01/binarySearch/"/>
    <url>/2020/12/01/binarySearch/</url>
    
    <content type="html"><![CDATA[<h2 id="二分查找">二分查找</h2><pre><code>1. 在有序数组nums中查找值为target的下标，查找失败返回-1</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><pre><code>2. 在有序数组nums中查找都一个比target大的数,失败返回</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.size() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> ans = nums.size();<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>            <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><pre><code>3. 在有序数组nums中查找都target第一次出现和最后一次出现的位置,失败返回[-1,-1].输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]</code></pre><p><strong>思路</strong>: 首先先用二分查找找到第一个target出现的位置left，然后查找第一个大于target的位置right，然后用right-1就是target出现最后一次的位置，代码如下 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = binarySearch(nums, target, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">int</span> right = binarySearch(nums, target, <span class="hljs-literal">false</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (left &lt;= right &amp;&amp; right &lt; nums.size()  &amp;&amp; nums[left] == target &amp;&amp; nums[right] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &#123;left, right&#125;; <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">bool</span> flag)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> right = nums.size() - <span class="hljs-number">1</span> ;<br>        <span class="hljs-keyword">int</span> ans = nums.size();<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target || (flag &amp;&amp; nums[mid] &gt;= target)) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>                ans = mid;<br>            &#125; <span class="hljs-keyword">else</span>  &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fourSumCount</title>
    <link href="/2020/11/29/fourSumCount/"/>
    <url>/2020/11/29/fourSumCount/</url>
    
    <content type="html"><![CDATA[<h2 id="四数之和"><a href="https://leetcode-cn.com/problems/4sum-ii/">四数之和</a></h2><pre><code>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</code></pre><p><strong>思路</strong> 使用散列表，先将数组A和B中任意两个数之和放入哈希映射中，每一个键是A[i]+B[j],值是对应的次数。然后在数组C和D之间相对应的建，当遇到-(C[k]+D[l])，则答案加1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; B, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; C, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; D)</span> </span>&#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; count;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;u : A) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;v : B) &#123;<br>                ++count[u+v];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;u : C) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;v : D) &#123;<br>                <span class="hljs-keyword">if</span> (count.count(-u-v))<br>                    ret += count[-(u+v)];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>convex-optimization</title>
    <link href="/2020/11/27/convex-opt/"/>
    <url>/2020/11/27/convex-opt/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-2">Chapter 2</h1><h2 id="convex-set">convex set</h2><h3 id="affine-and-convex-set">2.1 Affine and convex set</h3><h4 id="lines-and-line-segment">2.1.1 Lines and line segment</h4><h4 id="affine-sets">2.1.2 Affine sets</h4><p>​ A set <span class="math inline">\(C \in R^n\)</span> is <strong>affine</strong> if the line through any two distinct points in C lies in C. We refer to a point of the form $ _1x_1++_k x_k$, where $_1++_k=1 $, as an affine combination of points <span class="math inline">\(x_1,\dots,x_k\)</span>. If C is an affine set, <span class="math inline">\(x_1,\dots,x_k \in C\)</span> and<span class="math inline">\(\theta_1+\dots+\theta_k=1\)</span>,then the point <span class="math inline">\(\theta_1x_1+\dots+\theta_k x_k\)</span> also belongs to C.</p><p>​ The set of all affine combinations of points in some <span class="math inline">\(C\subseteq R^n\)</span> is called the <strong>affine hull（仿射包）</strong>of C, and denoted <strong>aff</strong> C: <span class="math display">\[aff\quad C = \{\theta_1x_1+\dots+\theta_k x_k | x_1, \dots,x_k \in C, \theta_1+\dots+\theta_k=1\}\]</span> The affine hull is the smallest affine set that contains C.</p><h4 id="affine-dimension-and-relative-interior">2.1.3 Affine dimension and relative interior</h4><p>​ The <strong>affine dimension</strong> of a set C as the dimension of its affine hull.</p><p>​ The <strong>relative interior</strong> of a set C is denoted <strong>relint C</strong>,as its interior relative to <strong>aff C</strong>: <span class="math display">\[relint \quad C=\{x\in C|B(x,r) \cap aff \quad C \subseteq C \quad for \quad some \quad r&gt;0\}\]</span> where <span class="math inline">\(B(r,x)=\{ y| ||y-x|| \le r\}\)</span>.</p><p>​ The <strong>relative boundary</strong> of a set C as cl C  relint C, where cl C is the closure of C.</p><h4 id="convex-set-1">2.1.4 Convex set</h4><p>​ A set C is convex if the line segment between any two point in C lies in C. i.e., if any <span class="math inline">\(x_1,x_2 \in C\)</span> and any <span class="math inline">\(\theta \in [0,1]\)</span>, we have <span class="math inline">\(\theta x_1+(1-\theta)x_2 \in C\)</span>.</p><p>​ We call a point of the from <span class="math inline">\(\theta_1x_1+\dots+\theta_k x_k\)</span>, where <span class="math inline">\(\theta_1+\dots+\theta_k=1\)</span> and <span class="math inline">\(\theta_i \ge 0, i=1,\dots,k\)</span>, a convex combination of the points <span class="math inline">\(x_1,\dots,x_k\)</span>.</p><p>​ The convex hull of a set C,denoted <strong>conv C</strong>, is the set of all convex combinations of points in C：</p><p><span class="math display">\[convC=\{\theta_1x_1+\dots+\theta_k x_k | x_1, \dots,x_k \in C, \theta_1+\dots+\theta_k=1, \theta_i \ge 0, i=1,\dots,k\}\]</span></p><h4 id="cones">2.1.5 Cones</h4><p>​ A set C is called a cone, if for every <span class="math inline">\(x \in C\)</span> and <span class="math inline">\(\theta \ge 0\)</span>,we have <span class="math inline">\(\theta x \in C\)</span>. A set C is convex cone if it is convex and a cone.</p><h3 id="section">2.2</h3><h4 id="hyperplanes-and-halfspaces">2.2.1 Hyperplanes and halfspaces</h4><p>​ A hyperplane is a set of the form <span class="math inline">\(\{x|a^Tx=b\}\)</span>, where <span class="math inline">\(a\in R^n,a\ne 0\)</span> and <span class="math inline">\(b\in R\)</span>. It also has the form <span class="math inline">\(\{x|a^T(x-x_0)=0\}\)</span>, where <span class="math inline">\(x_0\)</span>is any point in the hyperplane(any point satisfies <span class="math inline">\(a^Tb=0\)</span>).</p><h4 id="euclidean-balls-and-ellipsoids">2.2.2 Euclidean balls and ellipsoids</h4><p>​ A ball in <span class="math inline">\(R^n\)</span> has the form <span class="math inline">\(B(x_c,r)=\{x| \quad\left\|x-x_c\right\|_2\le r \}=\{x| (x-x_c)^T(x-x_c) \le r^2\}\)</span></p><h4 id="norm-balls-and-norm-cones">2.2.3 Norm balls and norm cones</h4><p>​ A norm ball associated with the norm <span class="math inline">\(\left \|·\right \|\)</span> is the set <span class="math inline">\(\{x | \left\|x-x_c\right\| \le r\}\)</span>.</p><p>​ A norm cones associated with the norm <span class="math inline">\(\left \|·\right \|\)</span> is the set <span class="math inline">\(\{(x,t) | \left\|x\right\| \le t\}\)</span>.</p>]]></content>
    
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长字串</title>
    <link href="/2020/11/26/first/"/>
    <url>/2020/11/26/first/</url>
    
    <content type="html"><![CDATA[<h3 id="字符串">字符串</h3><ul><li><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度</a></p><p><strong>输入实例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度 3</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>思路</strong></p><p>​ 采用滑动窗口的思想，设置两个指针，一个指针<strong>i</strong>指向左边，一个指针<strong>rk</strong> 指向右边，此时最长的字符字串为<strong>s[i]s[i+1]...s[rk]</strong></p><p>，此时长度为<strong>rk-i+1</strong>。具体思路如下所示:</p><ol type="1"><li><p>abcabcbb,首先i指针指向第一个字符，可以得到最长的无重复字符字串为(abc)abcbb, ()表示最长的无重复字符字串。</p></li><li><p>abcabcbb a(bca)bcbb</p></li><li><p>abcabcbb,ab(cab)cbb</p></li><li><p>abcabcbb,abc(abc)bb</p></li><li><p>abcabcbb,abca(bc)bb</p></li><li><p>abcabcbb,abcab(cb)b</p></li><li><p>abcabcbb,abcabcb(b)</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">char</span>&gt; check;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">int</span> rk = <span class="hljs-number">-1</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                check.erase(s[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (rk + <span class="hljs-number">1</span> &lt; s.size() &amp;&amp; check.count(s[rk + <span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>)&#123;<br>                check.insert(s[rk + <span class="hljs-number">1</span>]);<br>                ++rk;<br>            &#125;<br>            res = max(res, rk - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
